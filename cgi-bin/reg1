#!/usr/bin/env perl
use strict;
use warnings;

use Template;
use CGI;
use CGI::Carp qw/fatalsToBrowser/;
my $q = CGI->new();
print $q->header();

use lib '.','../lib';
use HousingNames;
use DateRange qw/
    overlap
/;

use Date::Simple qw/
    date
    today
/;
my $today = today();

use Util qw/
    db_init
    model
    JON
/;
my $c = db_init();
use Global qw/
    %string
/;
Global->init($c, 1, 1);     # to get %strings:

use Time::Simple qw/
    get_time 
/;
use Slurp qw/
    slurp
/;

my $words = '/var/Reg/words';

my $pid  = $q->param('id');

my %stash;
$stash{pid}  = $pid;

sub oops {
    my ($err) = @_;
    Template->new(INTERPOLATE => 1)->process(
        'err.tt2',
        { err => $err },
    );
    exit;
}

my $mountain_experience = $q->param('mountain_experience');
$stash{mountain_experience} = $mountain_experience;

my $only_outdoors = 0;
my $PR_ndays = 0;
if ($pid == 0) {
    my $arr_date = $q->param('arr_date');       # for PRs and MEs
    my $dep_date = $mountain_experience? $arr_date: $q->param('dep_date');
    my $sdate = date($arr_date);    # this will not die
    my $edate = date($dep_date);
    $stash{sdate} = $sdate;
    $stash{edate} = $edate;

    if ($mountain_experience) {
        #
        # Mountain Experience dates are adequately restricted in regME
        # No need to check them here.
        #
        my $me_max = $string{me_max};

        #
        # are there any Configuration > Date Ranges for ME
        # that span the date?
        #
        my @lines = slurp("$words/date_ranges.txt");
        chomp @lines;
        LINE:
        for my $l (@lines) {
            my ($type, $range, $max) = split ' ', $l;
            next LINE unless $type eq 'ME';
            my ($start, $end) = split '-', $range;
            $start = date($start);
            $end = date($end);
            if ($start <= $sdate && $sdate <= $end) {
                $me_max = $max;
            }
        }

        my (@me_regs) = model($c, 'Registration')->search({
                                mountain_experience => { '!=' => '' },
                                date_start => $sdate->as_d8(),                
                        });
        my $n_me_regs = @me_regs;
        if ($n_me_regs >= $me_max) {
            # could this date have been restricted in regME?
            # yes.  maybe later. too many dates to look at...
            # forget it.
            #
            oops "Sorry, we have reached the maximum capacity"
               . " for Mountain Experience Retreats on $sdate.\n";
        }

        my @meals; 
        if ($q->param('lunch')) {
            push @meals, 'Lunch';
        }
        if ($q->param('dinner')) {
            push @meals, 'Dinner';
        }
        if (!@meals) {
            oops 'Surely, you want to eat either lunch or dinner!';
        }
        my @activities;
        if ($q->param('yoga_class')) {
            push @activities, "Yoga Class";
        }
        if ($q->param('guided_hike')) {
            push @activities, "Guided Walk";
        }
        $stash{meals} = join ' and ', @meals;
        $stash{activities} = join ' and ', @activities;

        # children's names and ages?
        my $name_age = $q->param('children_name_age');
        if ($name_age) {
            my @names = $name_age =~ m{([a-z]+)}xmsgi;
            my @ages  = $name_age =~ m{(\d+)}xmsg;
            if (@names != @ages) {
                oops "Some problem with the names and ages of the children.";
            }
            my @children;
            CHILD:
            for my $i (0 .. $#ages) {
                if ($ages[$i] > 12) {
                    oops "$names[$i] needs to register separately.";
                }
                if ($ages[$i] < 5) {
                    next CHILD;
                }
                push @children, ucfirst $names[$i] . " $ages[$i]";
            }
            $stash{children_name_age} = join ', ', @children;
        }
    }
    else {
        #
        # Personal Retreats
        #
        $PR_ndays = $edate-$sdate;
        my $PRdr = DateRange->new($sdate, $edate-1);

        my $max_nights = $string{pr_max_nights};
        if ($PR_ndays > $max_nights) {
            oops "Sorry, you can stay a maximum of $max_nights nights.";
        }

        #
        # For PRs we need to check the dates
        # arr_date and dep_date from the request
        # and compare them to the dates in No PR events
        # and maybe set a flag to exclude indoor housing below
        # No PR date ranges ARE excluded in regPR
        # but they may choose a date range that starts
        # and ends on acceptable dates but includes a date
        # that is excluded - so we still need to check.
        #
        my (@events) = model($c, 'Event')->search(
            {
                name  => { 'regexp' => '[[:<:]]No[[:>:]].*[[:<:]]PRs?[[:>:]]' },
                edate => { '>='   => today()->as_d8() },
            },
            {
                order_by => 'sdate',
            }
        );
        for my $ev (@events) {
            my $ev_sd = $ev->sdate_obj;
            my $ev_ed = $ev->edate_obj - 1;
            my $EVdr = DateRange->new($ev_sd, $ev_ed);
            my $indoors = $ev->name =~ m{\bindoors\b}xmsi;
            # is there overlap?
            if (overlap($PRdr, $EVdr)) {
                if ($indoors) {
                    $only_outdoors = 1;
                }
                else {
                    my $err .= "Sorry, you cannot stay the nights from ";
                    if ($ev_sd->month() == $ev_ed->month()) {
                        $err .= $ev_sd->format("%B %e")
                             .  "-"
                             .  $ev_ed->format("%e")
                             ;
                    }
                    else {
                        $err .= $ev_sd->format("%B %e")
                             .  "-"
                             .  $ev_ed->format("%B %e")
                             ;
                    }
                    $err .= '.';
                    oops $err;
                }
            }
        }

        # Has a maximum for PRs been reached already?
        # on any of the dates in the range.
        # it's close.  maybe off by one somewhere. test it.

        # PR max
        my $pr_max = $string{pr_max};

        my @maximums = ($pr_max) x $PR_ndays;

        #
        # are there Configuration > Date Ranges for PR that span the date?
        #
        my @lines = slurp("$words/date_ranges.txt");
        chomp @lines;
        LINE:
        for my $l (@lines) {
            my ($type, $range, $max) = split ' ', $l;
            next LINE unless $type eq 'PR';
            my ($start, $end) = split '-', $range;
            $start = date($start);
            $end   = date($end);
            my $dr2 = DateRange->new($start, $end);
            if (my $dr3 = overlap($PRdr, $dr2)) {
                for (my $d = $dr3->sdate; $d <= $dr3->edate; ++$d) {
                    $maximums[$d-$sdate] = $max;
                }
            }
        }

        JON "Maximums = @maximums";

        # Look for overlapping existing PR registrations
        my (@pr_regs) = model($c, 'Registration')->search(
                        {
                            date_start => { '<=' => $edate->as_d8() },
                            date_end   => { '>=' => $sdate->as_d8() },
                            'program.name' => { -like => '%personal%retreat%' },
                            mountain_experience => '',
                        },
                        {
                            join     => [qw/ program /],
                            prefetch => [qw/ program /],
                            order_by => 'date_start asc',
                        }

                        );
        my @PR_total;
        for my $r (@pr_regs) {
            JON $r->person->name . ' = '
              . $r->date_start_obj . ' to ' . ($r->date_end_obj-1);
            my $dr = DateRange->new($r->date_start_obj, $r->date_end_obj-1);
            my $ov = overlap($dr, $PRdr);
            if ($ov) {
                # should always be an overlap
                JON "ov = " . $ov->show;
                for (my $d = $ov->sdate; $d <= $ov->edate; ++$d) {
                    ++$PR_total[$d-$sdate];
                }
            }
        }
        JON "PR totals = @PR_total";

        for my $i (0 .. $#maximums) {
            if ($PR_total[$i] >= $maximums[$i]) {
                oops "Sorry, on " . ($sdate+$i)->format("%D")
                   . " the maximum # of Personal Retreats has been reached!";
            }
        }

=comment

        # < $edate because they're leaving on that date
        for (my $d = $sdate; $d < $edate; ++$d) {
            if ($n >= $pr_max) {
                oops "Sorry, we have reached the maximum capacity for Personal Retreats on $d.\n";
            }
        }

=cut

    }

    $stash{pr} = 1;
    my $dates = "$PR_ndays day"
              . (($PR_ndays > 1)? "s": "")
              . " from "
              . $sdate->format("%A %B %e, %Y")
              . " to "
              . $edate->format("%A %B %e, %Y")
              ;
    $stash{pr_dates} = $dates;
    $stash{outdoors} = $only_outdoors;
}

=comment

reg1 takes a program id on the command line.
it looks it up in the file 'progtable' to get the 
various attributes of a program with that id.
it then fills in reg1.tt2 with
these various attributes and presents
it to the user.

if there is cookie information, it will also be used.

my $href = do "$progpath/progtable";
# get the PR progtable as well
my $pr_href = do "$progpath/pr/progtable";
$href->{0} = $pr_href->{0};
if ($@) {
    print "error in progtable: $@\n";
    exit;
}
if (! exists $href->{$pid}) {
    print "Sorry, program not found.\n";
    exit;
}
my $data = $href->{$pid};
my %cookie = cookie(-name => 'user_data');

#
# has the end registration date/time passed?
#
my $erdt = $data->{end_reg_date_time};
if ($erdt =~ m{\S}xms) {
    my ($end_date, $end_time)
        = $erdt =~ m{(\d\d/\d\d/\d\d\d\d) \s+ (\d\d:\d\d)}xms;
    # convert to Date, Time objects
    $end_date = date($end_date);
    $end_time = get_time($end_time);
    my $now = get_time();
    if ($end_date < $today
        ||
        ($end_date == $today && $end_time < $now)
    ) {
        print "Sorry, the registrations for <b>$data->{title}</b> are now closed.\n";
        exit;
    }
}

#
# have we reached the maximum number of allowed registrations
# for this program?
#
my $max = $data->{max};
if ($max) {
    my $ref = decode_json slurp('/var/www/mount-madonna-center/config.json');
    my $db = $ref->{database};
    my $dbh = DBI->connect("DBI:mysql:database=for_reg",
                           $db->{user}, $db->{password},
                           { RaiseError => 1, AutoCommit => 1 }
              ) or die "cannot connect to for_reg database\n";
    my $sth = $dbh->prepare(<<'EOS');
        SELECT COUNT(*)
          FROM prog_registrations
         WHERE prog_id = ?
EOS
    $sth->execute($pid);
    my ($n) = $sth->fetchrow_array();
    if ($n >= $max) {
        print "Sorry, we have reached the maximum capacity for <b>$data->{title}</b>.\n";
        exit;
    }
}

# TODO: complain if you try to register for a program that has already happened.

for my $w (qw/
    title dates leader_names name
    canpol do_not_compute_costs dncc_why
    plink deposit kayakalpa children_welcome
    collect_total donation donation_msg
    covid_vax confnote strangers_share
    reg_msg discount_code
    type
/) {
    $stash{$w} = $data->{$w};
}
$stash{tuition} = ($data->{tuition} != 0)? ', tuition,': '';

if ($mountain_experience) {
    # MEs have a difference cancellation policy
    # from PRs.
    $stash{canpol} = $data->{me_canpol};
}
for my $w (qw/  confnote reg_msg  /) {
    if ($stash{$w} eq '<p><br mce_bogus="1"></p>') {
        $stash{$w} = '';
    }
}
for my $t (qw/
    reg_start
    reg_end
    prog_start
    prog_end
/) {
    $stash{$t} = get_time($data->{$t})->ampm();
}
my $images = do "image_links/$pid";
if ($images->{image1} && $images->{image2}) {
    $stash{two_pics} = 1;
    $stash{image1} = $images->{image1};
    $stash{image2} = $images->{image2};
}
elsif ($images->{image1}) {
    $stash{one_pic} = 1;
    $stash{image1} = $images->{image1};
}
else {
    $stash{zero_pics} = 1;
}
$stash{basicfull} = ($data->{ndays} != $data->{fulldays});
$stash{bdays}     = $PR_ndays || $data->{ndays};
$stash{bdays_pl}  = $stash{bdays} == 1? '': 's';
$stash{fdays}     = $data->{fulldays};
if ($stash{basicfull}) {
    # muck with the dates
    ($stash{bdates}, $stash{fdates}) = split m{,}, $data->{dates};
    if ($stash{fdates} =~ m{^\s*\d}) {
        my ($month) = $stash{bdates} =~ m{([a-z]+)}i;
        $stash{fdates} = "$month " . $stash{fdates};
    }
}

# Gender Identity
for my $g (qw/ female male non_binary trans no_resp /) {
    $stash{$g} = '';
}
$stash{$cookie{gender}} = 'checked';

if ($cookie{cabin_room} eq 'cabin') {
    $stash{cabin} = "checked";
    $stash{room}  = "";
}
else {
    $stash{cabin} = "";
    $stash{room}  = "checked";
}
# Carpooling
$stash{carpool}        = $cookie{carpool}? 'checked': '';
$stash{hascar}         = $cookie{hascar}? 'checked': '';
my $fw = $cookie{from_where};
if ($fw eq 'SJC') {
    $stash{sjc_checked} = 'checked';
}
elsif ($fw eq 'SFO') {
    $stash{sfo_checked} = 'checked';
}
else {
    $stash{home_checked} = 'checked';
}
$stash{from_where_display} = $stash{carpool}? 'block': 'none';

$stash{e_mailings}     = $cookie{e_mailings}? 'checked': '';
$stash{snail_mailings} = $cookie{snail_mailings}? 'checked': '';
$stash{share_mailings} = $cookie{share_mailings}? 'checked': '';
$stash{withwhom_first} = $cookie{withwhom_first} || "";
$stash{withwhom_last}  = $cookie{withwhom_last}  || "";
for my $w (qw/
    fname lname aname street1 street2
    city state zip country
    cell
    email1
    car_license
    pronouns
    diet
/) {
    $stash{$w} = $cookie{$w} || "";
}
$stash{email2} = $cookie{email1} || "";

$stash{mft} = $data->{footnotes} =~ m{[*][*]};
$stash{ceu} = $data->{footnotes} =~ m{[*]};
$stash{ceu_license} = $cookie{ceu_license};
$stash{car_license} = $cookie{car_license};

# housing
#
my @housekeys = grep { /^basic / } keys %$data;

if (exists $data->{next_hc} && $data->{next_hc}) {
    $stash{next_hc} = $data->{next_hc};
    $stash{through_date} = date($data->{next_date})->prev->format("%b %e");
    $stash{next_date} = date($data->{next_date})->format("%b %e");
}
$stash{housing_not_needed} = $mountain_experience? 1
                            :                      $data->{housing_not_needed};
my $housing_fees = "";
HOUSING_TYPE:
for my $k (sort { $data->{$b} <=> $data->{$a} } @housekeys) {
    if ($data->{$k} == 0) {
        # not available
        next HOUSING_TYPE;
    }
    if ($pid == 0 && $k =~ m{commuting}xms) {
        # per Savita 6/15/22
        next HOUSING_TYPE;
    }
    if ($only_outdoors && $k =~ m{single|dble}xms) {
        next HOUSING_TYPE;
    }
    if ($stash{pr} && $k =~ m{center}xms && $no_center_tents) {
        next HOUSING_TYPE;
    }
    my $nk = $k;
    $nk =~ s{basic }{};
    my $full = $k;
    $full =~ s{basic}{full};
    my $next = $k;
    $next =~ s{basic}{next};
    my $select1 = $cookie{house1} eq $nk? 'checked': '';
    my $select2 = $cookie{house2} eq $nk? 'checked': '';
    $housing_fees .= <<"EOH";
<tr>

<td style="text-align: center">
<input type=radio name=house1 value='$nk' $select1>
</td>

<td style="text-align: center">
<input type=radio name=house2 value='$nk' $select2>
</td>

<td>$housing_name{$nk}</td>
EOH
    if (! $stash{do_not_compute_costs}) {
        $housing_fees .= "<td align=right width=50>\$$data->{$k}</td>\n";
        if ($stash{basicfull}) {
            $housing_fees .= "<td align=right width=70>\$$data->{$full}</td>\n";
        }
        elsif ($data->{next_hc}) {
            $housing_fees .= "<td align=right width=70>\$$data->{$next}</td>\n";
        }
    }
    $housing_fees .= "</tr>\n";
}
$stash{housing_fees} = $housing_fees;

# donation
my $donation_input;
if ((my $s = $data->{donation_tiers}) =~ m{\S}xms) {
    my $other = index(lc $s, 'other') >= 0;
    my @nums = $s =~ m{(\d+)}xmsg;
    my ($default) = $s =~ m{(\d+)\s*[*]}xms;
    for my $n (@nums) {
        my $checked = $n == $default? 'checked': '';
        $donation_input .= <<"EOH";
<li>
<input type=radio name=donation_tier id=donation_$n value=$n $checked>
<label for="donation_$n"> \$$n</label>
</li>
EOH
    }
    if ($other) {
        $donation_input .= <<'EOH';
<li>
<input type=radio
       name=donation_tier
       id=donation_other
       value=other
       onclick="document.getElementById('donation_tier_other_amount').focus();"
>
<label for="donation_other"> Other: &nbsp;&nbsp;
<input type=text
       name=donation_tier_other_amount
       id=donation_tier_other_amount
       style="width: 1in"
       onfocus="document.getElementById('donation_other').checked = true;"
>
</label>
</li>
EOH
    }
    $donation_input = "<fieldset><ol>$donation_input</ol></fieldset>";
}
elsif ($data->{donation}) {
    $donation_input = <<"EOH";
<div style="margin-top: .4in">
<input type=text name=donation id=donation class="input"> 
<label for="donation">Donation Amount</label>
</div>
EOH
}
$stash{donation_input} = $donation_input;

=cut


my $tt = Template->new(INTERPOLATE => 1);
$tt->process(
    'reg1.tt2',
    \%stash,
) or die $tt->error();

#!/usr/bin/env perl
use strict;
use warnings;

use Template;
use CGI;
use CGI::Carp qw/fatalsToBrowser/;
my $q = CGI->new();
print $q->header();

use lib '.','../lib';
use DateRange qw/
    overlap
/;

use Date::Simple qw/
    date
    today
/;
my $today = today();

use Util qw/
    db_init
    model
    get_string
    fee_types
    JON
    styled
/;
my $c = db_init();

use Time::Simple qw/
    get_time 
/;
use Slurp qw/
    slurp
/;

my $words = '/var/Reg/words';

my $pid  = $q->param('id');

my %stash;
$stash{pid}  = $pid;

sub oops {
    my ($err, $back) = @_;
    Template->new(INTERPOLATE => 1)->process(
        styled('err.tt2'),
        {
            back => $back,
            err  => $err 
        },
    );
    exit;
}

my $mountain_experience = $q->param('mountain_experience');
$stash{mountain_experience} = $mountain_experience;

my $only_outdoors = 0;
my $PR_ndays = 0;

# for PRs and MEs:
my $arr_date = $q->param('arr_date');
my $dep_date = $mountain_experience? $arr_date: $q->param('dep_date');
my ($sdate, $edate);
if ($arr_date) {
    $sdate = date($arr_date);    # this will not die
}
if ($dep_date) {
    $edate = date($dep_date);
}

if ($pid == 0) {
    $stash{sdate} = $sdate;
    $stash{edate} = $edate;

    if ($mountain_experience) {
        if (! $sdate) {
            oops "Please choose a date for your Mountain Experience.", 1;
        }
        #
        # Mountain Experience dates are adequately restricted in regME
        # No need to check them here.
        #
        my $me_max = get_string($c, 'me_max');

        #
        # are there any Configuration > Date Ranges for ME
        # that span the date?
        #
        my @lines = slurp("$words/date_ranges.txt");
        chomp @lines;
        LINE:
        for my $l (@lines) {
            my ($type, $range, $max) = split ' ', $l;
            next LINE unless $type eq 'ME';
            my ($start, $end) = split '-', $range;
            $start = date($start);
            $end = date($end);
            if ($start <= $sdate && $sdate <= $end) {
                $me_max = $max;
            }
        }

        my (@me_regs) = model($c, 'Registration')->search({
                                mountain_experience => { '!=' => '' },
                                date_start => $sdate->as_d8(),                
                        });
        my $n_me_regs = @me_regs;
        if ($n_me_regs >= $me_max) {
            # could this date have been restricted in regME?
            # yes.  maybe later. too many dates to look at...
            # forget it.
            #
            oops "Sorry, we have reached the maximum capacity"
               . " for Mountain Experience Retreats on "
               . $sdate->format("%A %B %e, %Y")
               . ".\n", 1;
        }

        my @meals; 
        if ($q->param('lunch')) {
            push @meals, 'Lunch';
        }
        if ($q->param('dinner')) {
            push @meals, 'Dinner';
        }
        if (!@meals) {
            oops 'Surely, you want to eat either lunch or dinner!', 1;
        }
        my @activities;
        if ($q->param('yoga_class')) {
            push @activities, "Yoga Class";
        }
        if ($q->param('guided_hike')) {
            push @activities, "Guided Walk";
        }
        $stash{meals} = join ' and ', @meals;
        $stash{activities} = join ' and ', @activities;

        # children's names and ages?
        my $name_age = $q->param('children_name_age');
        if ($name_age) {
            my @names = $name_age =~ m{([a-z]+)}xmsgi;
            my @ages  = $name_age =~ m{(\d+)}xmsg;
            if (@names != @ages) {
                oops "Some problem with the names and ages of the children.", 1;
            }
            my @children;
            CHILD:
            for my $i (0 .. $#ages) {
                if ($ages[$i] > 12) {
                    oops "$names[$i] needs to register separately.", 1;
                }
                if ($ages[$i] < 5) {
                    next CHILD;
                }
                push @children, ucfirst $names[$i] . " $ages[$i]";
            }
            $stash{children_name_age} = join ', ', @children;
        }
    }
    else {
        #
        # Personal Retreats
        #
        $PR_ndays = $edate-$sdate;
        my $PRdr = DateRange->new($sdate, $edate-1);

        my $max_nights = get_string($c, 'pr_max_nights');
        if ($PR_ndays > $max_nights) {
            oops "Sorry, you can stay a maximum of $max_nights nights.", 1;
        }

        #
        # For PRs we need to check the dates
        # arr_date and dep_date from the request
        # and compare them to the dates in No PR events
        # and maybe set a flag to exclude indoor housing below
        # No PR date ranges ARE excluded in regPR
        # but they may choose a date range that starts
        # and ends on acceptable dates but includes a date
        # that is excluded - so we still need to check.
        #
        my (@events) = model($c, 'Event')->search(
            {
                name  => { 'regexp' => '[[:<:]]No[[:>:]].*[[:<:]]PRs?[[:>:]]' },
                edate => { '>='   => today()->as_d8() },
            },
            {
                order_by => 'sdate',
            }
        );
        for my $ev (@events) {
            my $ev_sd = $ev->sdate_obj;
            my $ev_ed = $ev->edate_obj - 1;
            my $EVdr = DateRange->new($ev_sd, $ev_ed);
            my $indoors = $ev->name =~ m{\bindoors\b}xmsi;
            # is there overlap?
            if (overlap($PRdr, $EVdr)) {
                if ($indoors) {
                    $only_outdoors = 1;
                }
                else {
                    my $err .= "Sorry, you cannot stay the nights from ";
                    if ($ev_sd->month() == $ev_ed->month()) {
                        $err .= $ev_sd->format("%B %e")
                             .  "-"
                             .  $ev_ed->format("%e")
                             ;
                    }
                    else {
                        $err .= $ev_sd->format("%B %e")
                             .  "-"
                             .  $ev_ed->format("%B %e")
                             ;
                    }
                    $err .= '.';
                    oops $err, 1;
                }
            }
        }

        # Has a maximum for PRs been reached already?
        # on any of the dates in the range.
        # it's close.  maybe off by one somewhere. test it.

        # PR max
        my $pr_max = get_string($c, 'pr_max');

        my @maximums = ($pr_max) x $PR_ndays;

        #
        # are there Configuration > Date Ranges for PR that span the date?
        #
        my @lines = slurp("$words/date_ranges.txt");
        chomp @lines;
        LINE:
        for my $l (@lines) {
            my ($type, $range, $max) = split ' ', $l;
            next LINE unless $type eq 'PR';
            my ($start, $end) = split '-', $range;
            $start = date($start);
            $end   = date($end);
            my $dr2 = DateRange->new($start, $end);
            if (my $dr3 = overlap($PRdr, $dr2)) {
                for (my $d = $dr3->sdate; $d <= $dr3->edate; ++$d) {
                    $maximums[$d-$sdate] = $max;
                }
            }
        }

        #JON "Maximums = @maximums";

        # Look for overlapping existing PR registrations
        # (that are not cancelled...:) )
        my (@pr_regs) = model($c, 'Registration')->search(
                        {
                            date_start => { '<=' => $edate->as_d8() },
                            date_end   => { '>=' => $sdate->as_d8() },
                            'program.name' => { -like => '%personal%retreat%' },
                            mountain_experience => '',
                            'me.cancelled' => { '!=' => 'yes' },
                        },
                        {
                            join     => [qw/ program /],
                            prefetch => [qw/ program /],
                            order_by => 'date_start asc',
                        }

                        );
        my @PR_total;
        for my $r (@pr_regs) {
            #JON $r->person->name . ' = ' . $r->date_start_obj . ' to ' . ($r->date_end_obj-1);
            my $dr = DateRange->new($r->date_start_obj, $r->date_end_obj-1);
            my $ov = overlap($dr, $PRdr);
            if ($ov) {
                # should always be an overlap
                #JON "ov = " . $ov->show;
                for (my $d = $ov->sdate; $d <= $ov->edate; ++$d) {
                    ++$PR_total[$d-$sdate];
                }
            }
        }
        #JON "PR totals = @PR_total";

        for my $i (0 .. $#maximums) {
            if ($PR_total[$i] >= $maximums[$i]) {
                oops "Sorry, on " . ($sdate+$i)->format("%D")
                   . " the maximum # of Personal Retreats has been reached!", 1;
            }
        }

        $stash{pr} = 1;
        my $dates = "$PR_ndays day"
                  . (($PR_ndays > 1)? "s": "")
                  . " from "
                  . $sdate->format("%A %B %e, %Y")
                  . " to "
                  . $edate->format("%A %B %e, %Y")
                  ;
        $stash{pr_dates} = $dates;
        $stash{outdoors} = $only_outdoors;
    }
}

my $prog;
if ($pid) {
    $prog = model($c, 'Program')->find($pid);
}
else {
    # PR or ME
    # find the Personal Retreat program containing the date $sdate
    my $d8 = $sdate->as_d8();
    ($prog) = model($c, 'Program')->search({
                name  => { -like => '%personal%retreat%' },
                sdate => { '<=' => $d8 },
                edate => { '>=' => $d8 },
            });
}
if (! $prog) {
    oops "Sorry, program not found.\n";
}

#
# is the program 'web ready'?
# has the end registration date/time passed?
# doesn't apply to PR and ME.
#
if ($pid) {
    if (! $prog->webready) {
        oops "Sorry, the program is not 'web ready'\n.";
    }
    my $title = '<b>' . $prog->title . '</b>';
    my $erdt = $prog->end_reg_date_time;
    if ($erdt =~ m{\S}xms) {
        my ($end_date, $end_time)
            = $erdt =~ m{(\d\d/\d\d/\d\d\d\d) \s+ (\d\d:\d\d)}xms;
        # convert to Date, Time objects
        $end_date = date($end_date);
        $end_time = get_time($end_time);
        my $now = get_time();
        if ($end_date < $today
            ||
            ($end_date == $today && $end_time < $now)
        ) {
            oops "Sorry, registrations for $title are now closed.";
        }
    }

    #
    # have we reached the maximum number of allowed registrations
    # for this program?  For ME and PR this is IN ADDITION
    # to the ways those are restricted to a maximum.  See above.
    #
    my $max = $prog->max;
    if ($max) {
        my @regs = model($c, 'Registration')->search({
                       program_id => $pid,
                       cancelled => { '!=' => 'yes' },
                   });
        if (@regs >= $max) {
            oops "Sorry, we have reached the maximum capacity for $title.", 1;
        }
    }

    if ($today > $prog->sdate_obj) {
        oops "The program $title has finished.<br>You cannot register for it today.";
    }
}

# ?? plink, type cancellation policy ??
for my $w (qw/
    title dates leader_names name
    cancellation_policy
    do_not_compute_costs dncc_why
    deposit kayakalpa children_welcome
    collect_total donation donation_msg
    covid_vax confnote strangers_share
    reg_msg discount_code tuition tuition_rolled full_tuition
/) {
    $stash{$w} = $prog->$w;
}
$stash{housecost_type} = $prog->housecost->type;

$stash{tuition_name} = $prog->tuition_name || 'tuition';
$stash{tuition_comma} = ($prog->tuition != 0)? "$stash{tuition_name},": '';

if ($mountain_experience) {
    # MEs have their own cancellation policy
    my ($canpol) = model($c, 'CanPol')->search({
                       name => 'Mountain Experience',
                   });
    $stash{canpol} = $canpol? $canpol->policy: 'cancellation policy for ME??';
}
else {
    $stash{canpol} = $prog->canpol->policy;
}
# remedy a tinyMCE quirk
for my $w (qw/  confnote reg_msg  /) {
    if ($stash{$w} eq '<p><br mce_bogus="1"></p>') {
        $stash{$w} = '';
    }
}
for my $t (qw/
    reg_start
    reg_end
    prog_start
    prog_end
/) {
    $stash{$t} = get_time($prog->$t)->ampm();
}

#
# for 'extra days' programs:
#
my $ndays = $prog->edate_obj - $prog->sdate_obj;
$stash{basicfull} = $prog->extradays;
$stash{bdays}     = $PR_ndays || $ndays;
$stash{fdays}     = $ndays + $prog->extradays;
if ($stash{basicfull}) {
    # muck with the dates
    ($stash{bdates}, $stash{fdates}) = split m{,}, $prog->dates;
    if ($stash{fdates} =~ m{^\s*\d}) {
        my ($month) = $stash{bdates} =~ m{([a-z]+)}i;
        $stash{fdates} = "$month " . $stash{fdates};
    }
}

if ($prog->reg_by_day) {
    # prepare the date_names array
    my $sdate = $prog->sdate_obj;
    my @date_names;
    for my $i (1 .. $ndays) {
        push @date_names, ($sdate + $i - 1)->format("%A, %B %e");
    }
    $stash{ndays} = scalar(@date_names);
    $stash{date_names} = \@date_names;
}

# Gender Identity
for my $g (qw/ female male non_binary trans no_resp /) {
    $stash{$g} = '';
}

# if there is cookie information, it will also be used.

my %cookie = $q->cookie(
    -domain => '.mountmadonna.org',
    -name   => 'user_data',
);
$stash{$cookie{sex}} = 'checked';

if ($cookie{cabin_room} eq 'cabin') {
    $stash{cabin} = "checked";
    $stash{room}  = "";
}
else {
    $stash{cabin} = "";
    $stash{room}  = "checked";
}
# Carpooling
$stash{carpool}        = $cookie{carpool}? 'checked': '';
$stash{hascar}         = $cookie{hascar} ? 'checked': '';
my $fw = $cookie{from_where};
if ($fw eq 'SJC') {
    $stash{sjc_checked} = 'checked';
}
elsif ($fw eq 'SFO') {
    $stash{sfo_checked} = 'checked';
}
elsif ($fw eq 'Home') {
    $stash{home_checked} = 'checked';
}

$stash{e_mailings}     = $cookie{e_mailings}    ? 'checked': '';
$stash{snail_mailings} = $cookie{snail_mailings}? 'checked': '';
$stash{share_mailings} = $cookie{share_mailings}? 'checked': '';
$stash{withwhom_first} = $cookie{withwhom_first} || "";
$stash{withwhom_last}  = $cookie{withwhom_last}  || "";
for my $w (qw/
    first last sanskrit addr1 addr2
    city st_prov zip_post country
    cell
    email1
    car_license
    pronouns
    diet
/) {
    $stash{$w} = $cookie{$w} || "";
}
$stash{email2} = $cookie{email1} || "";

$stash{mft} = $prog->footnotes =~ m{[*][*]};
$stash{ceu} = $prog->footnotes =~ m{[*]};
$stash{ceu_license} = $cookie{ceu_license};
$stash{car_license} = $cookie{car_license};
$stash{housing_not_needed}
    = $mountain_experience? 1
     :                      $prog->housing_not_needed;

my $hc = $prog->housecost();
$stash{house_cost_type} = $hc->type;
$stash{housing_fee_rows} = fee_types($c, $hc,
                               $only_outdoors,
                               $cookie{house1}, $cookie{house2});
$stash{cabin} =    $hc->single_cabin != 0
                || $hc->dble_cabin   != 0;

# donation - aka Tuition
my $donation_input;
if ((my $s = $prog->donation_tiers) =~ m{\S}xms) {
    my $other = index(lc $s, 'other') >= 0;
    my @nums = $s =~ m{(\d+)}xmsg;
    my ($default) = $s =~ m{(\d+)\s*[*]}xms;
    for my $n (@nums) {
        my $checked = $n == $default? 'checked': '';
        $donation_input .= <<"EOH";
<input type=radio name=donation_tier id=donation_$n value=$n $checked>
\$$n<br>
EOH
    }
    if ($other) {
        $donation_input .= <<'EOH';
<input type=radio
       name=donation_tier
       id=donation_other
       value=other
       onclick="document.getElementById('donation_tier_other_amount').focus();"
>
Other:
<input type=text
       name=donation_tier_other_amount
       id=donation_tier_other_amount
       style="width: 1in"
       onfocus="document.getElementById('donation_other').checked = true;"
>
EOH
    }
    $donation_input = $donation_input;
}
elsif ($prog->donation) {
    # not tiered
    # this is for a cold cash gift
    $donation_input = <<"EOH";
<b>Donation Amount:</b>
<input type=text name=donation id=donation> 
EOH
}
$stash{donation_input} = $donation_input;

my $tt = Template->new({
    INTERPOLATE => 1,
    ENCODING    => 'utf8',
});
$tt->process(
    styled('reg1.tt2'),
    \%stash,
) or die $tt->error();

#!/usr/bin/env perl
use strict;
use warnings;
use lib '../lib';

use CGI;
use CGI::Carp qw/fatalsToBrowser/;
my $q = CGI->new();
print $q->header();

use Util qw/
    db_init
    model
/;
my $c = db_init();

use Template;
use Date::Simple qw/
    date
    today
/;
Date::Simple->default_format("%b %e '%q");
#use JSON;
#use DBI;
#my $dbh = DBI->connect(
#    'dbi:SQLite:dbname=meal_requests.db', '', '',
#    { RaiseError => 1, AutoCommit => 1 }
#) or die "cannot connect to meal_requests.db database\n";
#my $sth_get_totals = $dbh->prepare(<<'EOS');
#    SELECT sum(breakfast) AS breakfast_tot,
#           sum(lunch)     AS lunch_tot,
#           sum(dinner)    AS dinner_tot
#      FROM meal_requests
#     WHERE date = ?
#EOS

my %string;
for my $s (model($c, 'String')->search({
               -or => [
                   the_key => { -like => '%breakfast%' },
                   the_key => { -like => '%lunch%' },
                   the_key => { -like => '%dinner%' },
                ],
           })
) {
    $string{$s->the_key} = $s->value;
}

sub pennies {
    my ($amt) = @_;
    $amt = sprintf "%.2f", $amt;
    $amt =~ s{[.]00$}{}xms;
    $amt;
}

sub oops {
    my ($msg) = @_;
    Template->new(
        INTERPOLATE => 1,
    )->process(
        "mr_err.tt2",
        { err => $msg },
    );
    exit;
}

my %stash;
my %cookie = $q->cookie(-name => 'user_data');
for my $w (qw/
    fname lname street1 street2
    city state zip country
    cell
    email1
/) {
    $stash{$w} = $cookie{$w} || "";
}
my $today = today();
my @date_ranges;
my @disabled;
for my $type (qw/ Meal Lunch /) {
    my (@events) = model($c, 'Event')->search(
        {
            name  => { 'regexp' => "No.*${type}" },
            edate => { '>='   => today()->as_d8() },
        },
        {
            order_by => 'sdate',
        }
    );
    for my $e (@events) {
        my ($sdate, $edate) = ($e->sdate_obj, $e->edate_obj);
        my $lunch = $type eq 'Lunch'? 1: 0;
        push @date_ranges, [ $sdate, $edate, $lunch ];
        my $d = $sdate;
        while ($d <= $edate) {
            push @disabled, $d->format("%m/%d/%Y");
            ++$d;
        }
    }
}
$stash{date_ranges} = \@date_ranges;
$stash{disabled} = join ', ', map { qq!'$_'! } @disabled;

my %params = $q->Vars();

sub no_lunch {
    my ($dt, $dates_aref) = @_;
    for my $dr (@$dates_aref) {
        if ($dr->[0] <= $dt && $dt <= $dr->[1]) {
            return 1;
        }
    }
    return 0;
}

if (my $t = delete $params{type}) {
    # $t is either 'family' or 'guest'
    $string{type} = $t;
    $stash{type} = $t;
    # overwrite the strings we use below with the
    # proper family or guest cost.
    for my $m (qw/ breakfast lunch dinner /) {
        $string{"$m\_cost"} = $string{"$m\_cost_$t"};
        $string{"$m\_cost_5_12"} = $string{"$m\_cost_5_12_$t"};
    }
}
if (! %params) {
    Template->new(
        INTERPOLATE => 1,
    )->process(
        "meal_request.tt2",
        {
            %string,
            %stash,
        },
    );
    exit;
}
my %totals;
my @requests;
DATE:
for my $i (1 .. 3) {
    my $d = $params{"date$i"};
    if (! $d) {
        next DATE;
    }
    my $dd = date($d);
    if (! $dd) {
        oops "Illegal date format: $d";
    }
    my $dow = $dd->day_of_week();
    my $saturday = $dow == 6;
    my $sunday   = $dow == 0;
    if ($dd - $today <= 1) {
        oops "Sorry, you must request meals 2 days in advance.";
    }
    if ($sunday) {
        oops "Sorry, you cannot request any meals on Sunday, "
           . $dd->format("%B %e '%q")
           . ".";
    }
    for my $dr (@date_ranges) {
                                              # dr->[2] may be 1 => Lunch
        if ($dr->[0] <= $dd && $dd <= $dr->[1] && ! $dr->[2]) {
            my $msg = "Sorry, you can't request a meal on $dd as it is ";
            if ($dr->[0] == $dr->[1]) {
                $msg .= " a date when meal requests are not allowed.";
            }
            else {
                $msg .= " is between $dr->[0] and $dr->[1] and meal requests are not allowed in that date range.";
            }
            oops $msg;
        }
    }
    my $r_href = {};
    $r_href->{date_obj} = $dd;
    $r_href->{d8} = $dd->as_d8();
    $r_href->{child} = $params{"child$i"};
    my $got_one = 0;
    for my $x (qw/ breakfast lunch dinner /) {
        my $v = $params{"$x$i"};
        if ($v && $v !~ m{^\s* \d+ \s* $}xms) {
            oops "Illegal number: $v";
        }
        if ($x eq 'lunch' && $v && $saturday) {
            oops "Sorry, No lunch on Saturday $dd.";
        }
        if ($x eq 'lunch' && no_lunch($dd, \@date_ranges)) {
            oops "Sorry, No lunch is served on $dd.";
        }
        $r_href->{$x} = $v || 0;
        if ($v) {
            $got_one = 1;
            $totals{$r_href->{d8}}{$x} += $v;
        }
    }
    if ($got_one) {
        push @requests, $r_href;
    }
    else {
        oops "No meals were requested on $dd.";
    }
}
if (! @requests) {
    oops "No dates!";
}
my $tot_cost = 0;
my $summary = '';
my @encoded_requests;
for my $r_href (@requests) {
    my $ch = $r_href->{child}? '_5_12': '';
    my $cost = $r_href->{breakfast}*$string{"breakfast_cost$ch"}
             + $r_href->{lunch}    *$string{"lunch_cost$ch"}
             + $r_href->{dinner}   *$string{"dinner_cost$ch"}
             ;
    $cost = pennies($cost);
    $summary .= 'On '
             .  $r_href->{date_obj}->format("%a %b %e '%q")
             . ': '
             ;
    my $who = $r_href->{child}? ' - for a child aged 5-12': '';
    $summary .= join ', ',
                map {
                    $r_href->{$_}? "$r_href->{$_} for $_": ()
                } 
                qw/ breakfast lunch dinner /
                ;
    $summary .= "$who: &nbsp;&nbsp; Cost \$$cost<br>\n";
    $tot_cost += $cost;
    push @encoded_requests, $r_href->{d8},
                            $r_href->{breakfast},
                            $r_href->{lunch},
                            $r_href->{dinner},
                            ($r_href->{child}? 1: 0)
                            ;
}
# have we exceeded a maximum?

=comment

for my $d8 (keys %totals) {
    $sth_get_totals->execute($d8);
    my %db_tots = %{ $sth_get_totals->fetchrow_hashref() };
    for my $m (keys %{$totals{$d8}}) {
        if ($db_tots{"$m\_tot"} + $totals{$d8}{$m}
                > $string{"$m\_daily_max"}
        ) {
            oops "Sorry, we have reached the maximum number"
               . " of meal requests for $m on "
               . date($d8) . ".";
        }
    }
}

=cut

$tot_cost = pennies($tot_cost);
$stash{total_cost} = $tot_cost;
if (@requests > 1) {
    $summary .= "<p>Total cost is \$$tot_cost";
}
$stash{summary} = $summary;
$stash{encoded_requests} = join ',', @encoded_requests;
Template->new(
    INTERPOLATE => 1,
)->process(
    "meal_request2.tt2",
    \%stash,
);

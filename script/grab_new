#!/usr/bin/env perl
use strict;
use warnings;
no warnings 'redefine';     # for Net::FTP::pasv

=begin comment

-1) Log everything that happens in the running of this script.
It is is run from cron in the background.
Insert records into the activity table.

0) Make sure that the net is available by trying to ping mountmadonna.org.
Otherwise simply exit.   Commented this part out...

1) Ftp-get all transaction files from www.mountmadonna.org
created by the 'relay' program.  The names of these files
are the ids of the most recent authorize.net transactions.
Put the files in /var/Reg/online.

1a) If one of the above transaction files has a line like
'x_description => Temple Donation ...'
it is a temple donation and requires special handling.   
Create a Payment record for the person to the 'Temple' Extra Account.
Send a proper thank you letter???

2) Get recently modified rental grid files into /var/Reg/grid.

3) Get mailing list requests (from MMC and MMI) into 
/var/Reg/mlist_done/$yyyy_mm and insert them into the people table.
In one email (to each office) let them know
the names and addresses so they can send them a brochure.

4) For registrations that indicated they would like
to be contacted about massage send Kaya Kalpa a letter
with their contact information and which program and when
they'll be here.

Also send the registrant a letter (actually it's the same letter
that they are Cc'ed on) saying that they will
be contacted by someone at Kaya Kalpa two to three weeks
before the program to arrange for the bodywork.

5) Get people that recently registered on the temple
reservation site and import them directly into the People table.

6a) Get MMI payment requests that have been paid and morph
them into actual payments.
6b) Get MMC payment requests that have been paid and morph
them into actual payments.

7) Get MMI standalone course registations

8) Get online membership payments

9) Get rental deposit payments

10) Get new HFS memberships

11) Get any new COVID vaccinations and affix them to the person
    or just get them for later use when an online registration
    is "brought in".

=end

=cut

use lib 'lib';
use Util qw/
    model
    db_init
    normalize
    add_or_update_deduping
    digits_only
    commify
    x_file_to_href
    email_letter
    slurp
/;

use RetreatCenterDB;    # ??? why can't we move this to Util?
use Global qw/
    %string
    %system_affil_id_for
/;

use Template;
use Date::Simple qw/
    date
    today
/;
use Time::Simple qw/
    get_time
/;
#use Net::Ping;
use Net::FTP;
# thanks to jnap and haarg
# a nice HACK to force Extended Passive Mode:
no warnings 'redefine';
*Net::FTP::pasv = \&Net::FTP::epsv;
use File::FTP;      # this is mine
use File::Basename 'basename';
use File::Copy 'copy';

use FindBin;
chdir "$FindBin::Bin/..";

# globals
my $today = today();
my $c;
my $ftp;
my $run_file = '/var/Reg/grab_running';
my $nomp = 0;
my ($now, $now_t24, $today_d8, $year_mon_dir);
my ($temple_xaccount_id, $meals_xaccount_id, $gift_cards_xaccount_id);
my @kayakalpa;  # an array of hashrefs - these people requested
                # information about bodywork.
my @mlist_alerts;   # an array of hashrefs - who to send
                    # brochures for MMI/MMC.

# directories
my ($online, $grid, $temple, $mlist_done, $meal_requests_done,
    $gift_cards_done,
    $req_mmi_dir, $req_mmc_dir, $omp_dir, $rental_deposit_dir,
    $new_hfs_dir, $temple_donation, $covid_vax_dir);
my $time_printed = 0;

sub msg {
    my ($row) = @_;
    model($c, 'Activity')->create({
        message => $row,
        cdate   => $today_d8,
        ctime   => $now_t24,
    });
}

sub quit {
    msg @_, "\n";
    unlink $run_file;
    exit;
}

sub failed {
    my ($rc) = @_;
    return $rc? '': ' - failed';
}

sub initialize {
    $now = get_time();
    $now_t24 = $now->t24;
    $today_d8 = $today->as_d8();
    $year_mon_dir = $today->format("%Y-%m");
    $c = db_init();
    Global->init($c, 1, 1);

    if (-f $run_file) {
        my $t = (stat($run_file))[9];
        if (time() - $t > 5*60) {
            #
            # a stale run file (older than 5 minutes).
            # it somehow got left behind from a previous run.
            # remove it and continue.
            # use the pid instead with kill?
            #
            unlink $run_file;
        }
        else {
            #
            # we have been invoked via "Grab New" in Reg.
            # but we are still validly running via cron!
            #
            quit("still running via cron");
        }
    }

    # touch the run file
    open my $run, ">", $run_file;
    close $run;

    if (! $ENV{FILE_FTP_DIR}) {     # are we testing or not?
        #my $p = Net::Ping->new();
        #if (!$p->ping("mountmadonna.org")) {
        #    quit("no ping of mountmadonna.org");
        #}
    }

    $string{mmc_email} = $string{reception_email};  # see *1 below

    # for temple donations
    my @xaccounts = model($c, 'XAccount')->search({
                        descr => 'Temple',
                    });
    if (@xaccounts == 1) {
        $temple_xaccount_id = $xaccounts[0]->id;
    }
    else {
        quit("could not find the Temple Extra Account");
    }
    # for meal requests
    @xaccounts = model($c, 'XAccount')->search({
                     descr => 'Meals',
                 });
    if (@xaccounts == 1) {
        $meals_xaccount_id = $xaccounts[0]->id;
    }
    else {
        quit("could not find the Meals Extra Account");
    }
    # for gift cards
    @xaccounts = model($c, 'XAccount')->search({
                     descr => 'Gift Cards',
                 });
    if (@xaccounts == 1) {
        $gift_cards_xaccount_id = $xaccounts[0]->id;
    }
    else {
        quit("could not find the Gift Cards Extra Account");
    }

    my $dir = "/var/Reg";
    $online          = make_dir("$dir/online");
    $grid            = make_dir("$dir/grid");
    $temple          = make_dir("$dir/temple_done/$year_mon_dir");
    $mlist_done      = make_dir("$dir/mlist_done/$year_mon_dir");
    $meal_requests_done = make_dir("$dir/meal_requests_done/$year_mon_dir");
    $gift_cards_done = make_dir("$dir/gift_cards_done/$year_mon_dir");
    $req_mmi_dir     = make_dir("$dir/req_mmi/$year_mon_dir");
    $req_mmc_dir     = make_dir("$dir/req_mmc/$year_mon_dir");
    $omp_dir         = make_dir("$dir/omp");
    $rental_deposit_dir = make_dir("$dir/rental_deposit/$year_mon_dir");
    $temple_donation = make_dir("$dir/temple_donation");
    $new_hfs_dir     = make_dir("$dir/new_hfs/$year_mon_dir");
    $covid_vax_dir   = make_dir("$dir/documents");
}

sub finalities {
    unlink $run_file;
    # at what point do the req_mmi_payments/req_mmc_payments expire???
    # a cron job on the remote site to clear them after n days?
    # also a cron job to clear the grid files after
    # the rental is over - two week delays?
    # ask/confirm with Rachel and Barnaby
}

sub ftp_connect {
    my (%arg) = @_;

    my $ftp_class = $ENV{FILE_FTP_DIR}? 'File::FTP': 'Net::FTP';
    my $ftp = $ftp_class->new($arg{site}, Passive => 1, Debug => 0)
        or quit("cannot connect to $arg{site}");
    $ftp->login($arg{login}, $arg{password})
        or quit("cannot login to $arg{site}: " . $ftp->message);
    $ftp->ascii();
    return $ftp;
}

sub make_dir {
    my ($d) = @_;
    mkdir $d if ! -d $d;
    return $d;
}

#
# using $ftp cd to the remote dir
# get all files there into $get_dir
# if $code_ref is supplied call it on each file.
#
sub get_files {
    my ($ftp, $remote_dir, $get_dir, $code_ref, @params) = @_;

    $ftp->cwd($remote_dir)
        or quit("cannot cwd to $remote_dir " . $ftp->message);
    mkdir $get_dir if ! -d $get_dir;
    my $nfiles = 0;
    FILE:
    for my $f ($ftp->ls()) {
        if ($f eq '.' || $f eq '..') {
            next FILE;
        }
        $ftp->get($f, "$get_dir/$f") or die "no get\n";
        ++$nfiles;
        if ($code_ref) {
            $code_ref->($get_dir, $f, @params);
        }
        $ftp->delete($f);
    }
}

sub check_transaction {
    my ($get_dir, $f, @params) = @_;

    my $href = x_file_to_href("$get_dir/$f");
    my $kk   = $href->{kayakalpa};
    my $desc = $href->{description};
    if ($kk && $kk eq 'yes') {
        push @kayakalpa, $href;
    }
    elsif ($desc && $desc =~ m{\A Temple \s+ Donation}xms) {
        # a special case
        temple_donation($href, $f);
        return;
    }
    if ($href->{days}) {
        # the Fall Reunion Retreat October 2019
        my $d = date('10/07/2019');
        my $suffix = 'a';
        for my $range (split '-', $href->{days}) {
            my @days = split //, $range;
            my $start = $days[0];
            my $end = $days[-1];        # may be the same as [0]
            my $fname = "$get_dir/$f$suffix";
            copy("$get_dir/$f", $fname);
            open my $out, '>>', $fname
                or die "cannot open $fname: $!\n";
            print {$out} "x_sdate => ", ($d+$start), "\n";
            print {$out} "x_edate => ", ($d+$end+1), "\n";
            if ($suffix ne 'a') {
                print {$out} "x_amount => 0\n";
                    # this will override the first one in the file
            }
            print {$out}
            close $out;
            ++$suffix;
        }
        unlink "$get_dir/$f";
    }
    msg "Online reg <a href='/registration/get_online/$f'>"
      . "$href->{first} $href->{last}</a>"
      . " for <a href='/program/view/$href->{pid}'>$href->{title}</a>"
      ;
}

sub check_grid {
    my ($get_dir, $f) = @_;
    my ($code) = $f =~ m{\A(.*)-}xms;
    my ($rental) = model($c, 'Rental')->search({
                       grid_code => $code,
                   });
    # look carefully at the file and update 3 columns in the Rental
    my $in;
    if (! open($in, "<", "$get_dir/$f")) {
        msg "could not open grid file $get_dir/$f\n";
        return;
    }
    #
    # we take care of the final day below
    # the web grid does not have a # for that last day
    #
    my $ndays = $rental->edate_obj() - $rental->sdate_obj();
    my @counts = (0) x $ndays;
    my $tot_cost = 0;
    LINE:
    while (my $line = <$in>) {
        chomp $line;
        if ($line =~ s{([\d.]*)$}{}) {
            my $cost = $1;
            if (! $cost) {
                next LINE;
            }
            $tot_cost += $cost;
        }
        my $name = "";
        # chop off the house id, the bed # and the name(s)
        if ($line =~ s{^\d+\|\d+\|([^|]*)\|}{}) {
            $name = $1;
        }
        my @peeps = split m{\&|\band\b}i, $name;
        my $np = @peeps;
        my @nights = split m{\|}, $line;
        for my $i (0 .. $#counts) {
            $counts[$i] += $np * $nights[$i];
        }
    }
    close $in;
    #
    # on the last day
    # the people who slept the night before will have breakfast
    # and maybe lunch.
    #
    push @counts, $counts[-1];
    my $max = 0;
    for my $c (@counts) {
        if ($max < $c) {
            $max = $c;
        }
    }
    $rental->update({
        counts         => (join ' ', @counts),
        grid_max       => $max,
        housing_charge => $tot_cost,
    });
    my $rname = $rental->name;
    my $rid = $rental->id;
    msg "grid <a href='/rental/view/$rid'>$rname</a>";
}

sub temple_donation {
    my ($href, $f) = @_;

    msg "temple donation \$$href->{amount}";

    # add the person if needed
    # ensure an affiliation is there.
    # add the payment to the Temple xaccount
    # move the file into the archive by month

    $href->{e_mailings} =
    $href->{snail_mailings} = 
    $href->{share_mailings} = -1;   # don't change these
                                    # it's just a donation

    my ($person_id, $person, $status) = add_or_update_deduping(
        $c, $href,
        affil_ids => $system_affil_id_for{'Temple Guest'},
    );
    msg sprintf "temple %s %s - %s",
                $person->first, $person->last, $status;
    # now we can add the payment record
    model($c, 'XAccountPayment')->create({
        xaccount_id => $temple_xaccount_id,
        person_id   => $person_id,
        amount      => $href->{amount},
        type        => 'O',               # online credit
        what        => 'Online temple donation',
        user_id     => 0,                 # what other user id?
        the_date    => $today_d8,
        time        => $now_t24,
    });
    # move the file into the archive - we have finished with it
    rename "$online/$f", "$temple_donation/$f";
    # email thank you again???
    # email temple people interested in what donations have come in???
}

#
#
# send the admins (mmc and mmi) a letter telling them
# who/where to send the brochure(s) - include the special requests.
#
sub mlist_alerts {
    return unless @mlist_alerts;
    TYPE:
    for my $type (qw/ mmc mmi /) {
        my $TYPE = uc $type;
        my $html = "";
        my @last_names;
        ALERT:
        for my $href (@mlist_alerts) {
            next ALERT if $href->{type} ne $type;
            $html .= <<"EOH";
<p>
$href->{first} $href->{last}<br>
$href->{addr1}<br>
$href->{city}, $href->{st_prov}<br>
$href->{zip_post}<br>
EOH
            if ($href->{country}) {
                $html .= "$href->{country}<br>\n";
            }
            $html .= "<a href='mailto:$href->{email}'>$href->{email}</a><br>\n";
            if ($href->{interest}) {
                $html .= "Interest: $href->{interest}<br>\n";
            }
            if ($href->{request}) {
                $html .= "Special Request: $href->{request}<br>\n"
            }
            push @last_names, $href->{last};
        }
        next TYPE if ! $html;
        my $email = $string{"$type\_email"};   # *1 mmc_email == reception_email
        my $last_names = join '/', @last_names;
        my $rc = email_letter($c,
            to      => $email,
            from    => 'Mount Madonna Center <reservations@mountmadonna.org>',
                    # what else???
            subject => "$last_names - Online $TYPE Mailing List Requests",
            html    => $html,
            activity_msg => "Email mailing list $TYPE alert to $email",
        );
    }
}

sub nights_for {
    my ($month) = @_;
    return $month <= 3? 4
          :$month <= 6? 3
          :$month <= 9? 2
          :             1
          ;
}

#
# what if someone become a member mid-year? or in December?
# valid_from date?
# valid_to date?
# sponsor nights?
# mem_type of general_ky will be essentially the same as general
#    Reg will not keep track of 20 hours of KY.
#    they'll pay $25 and just help out a bit
# no one checks at the meal line who is paying what rate...
# if someone knows they're a member they pay the member rate
#   by putting that amount on the sheet in the folder...
#
sub process_new_hfs {
    my ($get_dir, $f) = @_;
    my $href = x_file_to_href("$get_dir/$f");
    # missing keys - we're not a full mlist thingy
    $href->{gender} = '';
    for my $k (qw/ e_mailings snail_mailings share_mailings /) {
        $href->{$k} = -1;
    }
    my ($person_id, $person, $status) = add_or_update_deduping(
        $c, $href,
    );
    my ($month, $year) = ($today->month, $today->year);
    if ($month == 12) {
        # ??? is this right??  what about November?
        ++$year;
    }
    my $exp_date = date($year, 12, 31)->as_d8();
    my $pay_date = date($href->{date})->as_d8();
    my $pay_time = $href->{time};
    $pay_time =~ s{:}{}xms;     # we know it is in 24 hour time format
    my $general = $href->{mem_type} =~ /general/;
    my $mem_type = ucfirst $href->{mem_type};
    my $amount = $href->{amount};
    my $mem = $person->member();
    if (! $mem) {
        # new member
        $mem = model($c, 'Member')->create({
            person_id    => $person_id,
            category     => $mem_type,
            date_general => $general? $exp_date: '',
            date_sponsor => $general? '': $exp_date,
            date_life    => '',    # obsolete
            voter        => '',
            free_prog_taken => '',
            sponsor_nights  => $general? 0: nights_for($month),
            total_paid      => $general? 0: $amount,
                               # only relevant if sponsor???
        });
    }
    else {
        # existing member
        # recompute the total paid
        my $member_id = $mem->id();
        my $total = 0;
        for my $p (model($c, 'SponsHist')->search({
                       member_id => $member_id,
                       general   => { "!=", "yes" },
                   })
        ) {
            $total += $p->amount;
        }
        $mem->update({
            total_paid     => $total + ($general? 0: $amount),
            sponsor_nights => $general? 0: nights_for($month),
            category       => $general? "General": "Sponsor",
        });
    }
    my $mem_id = $mem->id();
    model($c, 'SponsHist')->create({
        member_id    => $mem_id,
        date_payment => $pay_date,
        valid_from   => $pay_date,      # ???
        valid_to     => $exp_date,
        amount       => $amount,
        type         => 'D',        # credit
        general      => $general? 'yes': '',
        the_date     => $pay_date,      # so many dates :(
        time         => $pay_time,
        user_id      => 2,      # sahadev = online...
        transaction_id => $href->{trans_id},
    });
    # for the extra account payment
    my @xaccounts = model($c, 'XAccount')->search({
                        descr => 'Membership',
                    });
    my $membership_xaccount_id;
    if (@xaccounts == 1) {
        $membership_xaccount_id = $xaccounts[0]->id;
    }
    else {
        quit("could not find the Membership Extra Account");
    }
    model($c, 'XAccountPayment')->create({
        person_id   => $person_id,
        xaccount_id => $membership_xaccount_id,
        what        => "New " . ucfirst($href->{mem_type}) . " Membership",
        amount      => $amount,
        type        => 'O',               # online
        user_id     => 2,                 # sahadev = online...
        the_date    => $pay_date,
        time        => $pay_time,
        transaction_id => $href->{trans_id},
    });
    model($c, 'NightHist')->create({
        member_id  => $mem_id,
        reg_id     => 0,
        num_nights => $general? 0: 4,       # ??? prorated?
        action     => 1,    # set nights
        the_date   => $pay_date,
        time       => $pay_time,
    });
    # need affiliations - see Member.pm
    #
    # make a Util function to receive a member payment
    # and call it in various places:
    # - here for new members
    # - online_member_payment (moved to grab_new)
    # - manual (not from online) adding in Member.pm
    #
    msg "NEW $mem_type membership - payment of \$$amount for "
      . "<a href='/member/view/$mem_id'>"
      . $person->name()
      . "</a>"
      ;
}

sub process_mlist {
    my ($get_dir, $f) = @_;

    # was it for mmi or mmc?
    open my $in, "<", "$get_dir/$f"
        or quit("cannot open $get_dir/$f: $!\n");
    my %hash;
    while (my $line = <$in>) {
        chomp $line;
        if (my ($key, $val) = $line =~ m{^(\w+)\s+(.*)}) {
            $hash{$key} = $val;
        }
        else {
            $hash{$line} = '';
        }
    }
    close $in;
    $hash{addr1} = $hash{street};
    $hash{addr2} = '';
    my $type = $hash{type};
    my $interest = $hash{interest};
    for my $k (qw/ cell home work /) {
        $hash{"tel_$k"} = $hash{$k};
    }
    $hash{sex} = $hash{gender} eq     'female'? 'F'
                :$hash{gender} eq       'male'? 'M'
                :$hash{gender} eq 'non_binary'? 'X'
                :                               ' ';
    $hash{request} =~ s{NEWLINE}{\n}g;
        # for the purposes of the file format
        # we needed the request to be on one line
        # so dealt with newlines like this.

    # remove unneeded ones
    for my $k (qw/
        street type interest
        cell home work gender
        email2
        Submit
    /) {
        delete $hash{$k};
    }
    my @affil_ids;
    if ($type eq 'mmi') {
        if ($interest eq 'All Schools') {
            for my $k (grep { /MMI/ } keys %system_affil_id_for) {
                push @affil_ids, $system_affil_id_for{$k};
            }
        }
        else {
            push @affil_ids, $system_affil_id_for{"MMI - $interest"};
        }
    }
    else {
        push @affil_ids, $system_affil_id_for{"MMC Annual Yoga Retreats"},
                         $system_affil_id_for{"MMC Hosted by MMC"};
    }
    my ($person_id, $person, $status) = add_or_update_deduping(
        $c, \%hash,
        affil_ids => \@affil_ids,
        request_to_comment => 1,
    );
    msg sprintf "$type mailing list %s %s - %s",
                $person->first, $person->last, $status;
    # record name, address for emailing all later to the reception office.
    # see sub mlist_alerts()
    # include type and comment
    #
    push @mlist_alerts, {
        type => $type,
        interest => $interest,
        map { $_ => $hash{$_} } qw/
            first last
            addr1 city st_prov zip_post country
            email
            request
        /,
    };
}

sub get_omp {
    my ($get_dir, $f) = @_;

    my ($mem_id, $amount, $transaction_id) = split '_', $f;
    my $member = model($c, 'Member')->find($mem_id);
    my $name = $member? $member->person->name(): "unknown person";
    msg "membership payment of \$$amount for $name";
    ++$nomp;
}

sub get_rental_deposit {
    my ($get_dir, $transaction_id) = @_;

    my %hash = %{ do "$get_dir/$transaction_id" };
    # this hash contains the keys 'id' and 'amount'
    # the id is the rental id
    # other keys are 'first' and 'last' - the name of the contact person
    #
    my $rental = model($c, 'Rental')->find($hash{id});
    # make a rental_payment
    model($c, 'RentalPayment')->create({
        amount    => $hash{amount},
        rental_id => $hash{id},
        type      => 'O',
        user_id     => 0,                 # what other user id?
        the_date    => $today_d8,
        time        => $now_t24,
    });
    # notify the rental coordinator(s)
    my $rlink = "$string{url_prefix}/rental/view/$hash{id}/3";
    email_letter($c,
        to      => $string{rental_coord_email},
        from    => 'Mount Madonna Center <reservations@mountmadonna.org>',
                                    # what else?
        subject => "Rental Deposit Received for " . $rental->name(),
        html    => "$hash{first} $hash{last} paid \$$hash{amount}"
                 . " for <a href='$rlink'>" . $rental->name() . "</a>",
        activity_msg => "Rental deposit of \$$hash{amount}"
                      . " for <a href='$rlink'>" . $rental->name . "</a>",
    );
}

sub omp_alert {
    if ($nomp) {
        email_letter($c,
            to      => "HFS Membership <$string{mem_email}>",
            from    => 'Mount Madonna Center <reservations@mountmadonna.org>',
            subject => "Membership Payment",
            html    => "There is an online membership payment waiting for you in Reg.",
            activity_msg => "Email membership payment waiting",
        );
    }
}

# Both MMI and MMC requested payments.
# $get_dir tells us which.
sub process_req_payments {
    my ($get_dir, $f) = @_;

    my $org = $get_dir =~ m{mmi}xms? 'MMI': 'MMC';
    my %hash = %{ do "$get_dir/$f" };
    #
    # this hash contains keys:
    #    py_desc
    #       which has multiple ~ separated fields
    #       which are | separated fields of
    #           amount, note, glnum
    #    code
    #    reg_id
    #    person_id
    #    total
    #    first
    #    last
    #    signed   (unused here)
    #    quest_email   (unused here)
    #
    # - create MMIPayment or RegPayment records with the above
    # - clear requested payments with the code
    # - adjust the balance in the registration
    # - log it
    #
    my $npy = 0;
    for my $py (split m{~}, $hash{py_desc}) {
        ++$npy;
        my ($amount, $note, $glnum) = split m{\|}, $py;
        $amount =~ s{,}{}xmsg;
        if ($org eq 'MMI') {
            model($c, 'MMIPayment')->create({
                reg_id    => $hash{reg_id},
                deleted   => '',
                the_date  => $today_d8,
                person_id => $hash{person_id},
                type      => 'O',       # online
                amount    => $amount,
                glnum     => $glnum,
                note      => $note,
            });
        }
        else {
            model($c, 'RegPayment')->create({
                reg_id   => $hash{reg_id},
                type     => 'O',       # online
                amount   => $amount,
                what     => $note,
                the_date => $today_d8,
                time     => get_time()->t24(),
                user_id  => 0,     # no user - this is a script
            });
        }
    }
    # remove all requests with the code
    my @req_py = model($c, 'RequestedPayment')->search({
        code => $hash{code},
    });
    if ($npy != @req_py) {
        msg "**** some mismatch with $org req_pay - "
           ."reg_id $hash{reg_id} npy $npy != " . scalar(@req_py);
    }
    else {
        for my $py (@req_py) {
            $py->delete();
        }
    }

    # History record
    model($c, 'RegHistory')->create({
        reg_id   => $hash{reg_id},
        the_date => $today_d8,
        time     => $now_t24,
        user_id  => 0,
        what     => "Got $org requested payment of \$" . commify($hash{total}) . '.',
    });

    # adjust the balance
    model($c, 'Registration')->find($hash{reg_id})->update({
        balance => \"balance - $hash{total}",
    });
# notify someone that the payment was made!???
    msg "requested $org payment totaling \$$hash{total} for $hash{first} $hash{last}";
}

sub process_meal_requests {
    my ($get_dir, $f) = @_;
    my $href = x_file_to_href("$get_dir/$f");
    # missing keys - we're not a full mlist thingy
    $href->{sex} = '';
    for my $k (qw/ e_mailings snail_mailings share_mailings /) {
        $href->{$k} = -1;
    }
    my ($person_id, $person, $status) = add_or_update_deduping(
        $c, $href,
    );
    my @terms = split ',', $href->{encoded_requests};
    my @mr_ids;
    my $mr_desc = "";
    while (@terms) {
        my ($date, $breakfast, $lunch, $dinner, $child) = splice @terms, 0, 5;
        $mr_desc .= date($date)->format("%b %e '%q") . ' - ';
        $mr_desc .= "$breakfast for breakfast, " if $breakfast;
        $mr_desc .= "$lunch for lunch, "         if $lunch;
        $mr_desc .= "$dinner for dinner"         if $dinner;
        $mr_desc =~ s{,\s+ \z}{}xms;    # chop a trailing ,
        $mr_desc .= ($child? ' for a child': '');
        $mr_desc .= '<br>';
        my $mr = model($c, 'MealRequests')->create({
            person_id => $person_id,
            date      => $date,
            breakfast => $breakfast,
            lunch     => $lunch,
            dinner    => $dinner,
            child     => $child,
            date_requested => date($href->{date})->as_d8(),
            time_requested => get_time($href->{time})->t24(),
        });
        push @mr_ids, $mr->id;
    }
    model($c, 'XAccountPayment')->create({
        person_id   => $person_id,
        xaccount_id => $meals_xaccount_id,
        what        => "online meal request<br>$mr_desc<!-- mr_ids @mr_ids -->",
            # we hide the ids (with an HTML comment)
            # so we can find them later
            # in case this payment is deleted.
        amount      => $href->{amount},
        type        => 'O',               # online
        user_id     => 0,                 # what other user id?
        the_date    => $today_d8,
        time        => $now_t24,
        transaction_id => $f,
    });
    $mr_desc =~ s{<br> \z}{}xms;        # chop the last <br>
    $mr_desc =~ s{<br>}{ | }xmsg;
    if ($href->{meal_type}) {
        $mr_desc .= " - $href->{meal_type}";
    }
    msg 'meal request for <a href=/person/view/' . $person->id . '>'
      . $person->name . '</a>, '
      . $mr_desc
      ;
}

sub process_gift_cards {
    my ($get_dir, $f) = @_;
    my $href = x_file_to_href("$get_dir/$f");
    # missing keys - we're not a full mlist thingy
    $href->{sex} = '';
    for my $k (qw/ e_mailings snail_mailings share_mailings /) {
        $href->{$k} = -1;
    }
    my ($person_id, $person, $status) = add_or_update_deduping(
        $c, $href,
    );
    my $rec_name = "$href->{rec_fname} $href->{rec_lname}";
    # payment to extra account
    model($c, 'XAccountPayment')->create({
        person_id   => $person_id,
        xaccount_id => $gift_cards_xaccount_id,
        what        => "$rec_name, code $href->{code}",
        amount      => $href->{amount},
        type        => 'O',               # online
        user_id     => 0,                 # what other user id?
        the_date    => $today_d8,
        time        => $now_t24,
        transaction_id => $f,
    });
    # create a GiftCard record ...
    model($c, 'GiftCards')->create({
        person_id   => $person_id,
        code        => $href->{code},
        amount      => $href->{amount},
        rec_fname   => $href->{rec_fname},
        rec_lname   => $href->{rec_lname},
        rec_email   => $href->{rec_email},
        the_date    => $today_d8,
        the_time    => $now_t24,
        transaction_id => $f,
        reg_id      => 0,
    });
    msg "gift card of \$$href->{amount} for $rec_name"
      . ' by <a href=/person/view/' . $person->id . '>'
      . $person->name . '</a>'
      ;
}

# the incoming filename is
#
#   $person_id.suffix
# or
#   FIRST_LAST_TIME.suffix
#
# in the /var/Reg/documents directory.
# we prepend 'covid_vax' to differentiate these files
# from other documents.
sub process_covid_vax {
    my ($get_dir, $f) = @_;
    my $cf = "covid_vax_$f";
    my ($suffix) = $f =~ m{[.](\w+) \z}xms;
    if (! $suffix) {
        # no suffix at all so assume a .jpg file
        # shouldn't happen since we did this on mmc.org as well...
        $cf .= "jpg";
    }
    elsif ($suffix eq 'jpeg') {
        $suffix = "jpg";
        $cf =~ s{jpeg}{jpg}xms;
    }
    if ($suffix eq '.pdf') {
        # convert to a .jpg and resize/compress it
        # couldn't do this on mountmadonna.org or here with IM6
        # we installed pdftoppm and it does work okay
        #
        my $new = "$get_dir/$cf";
        $new =~ s{.pdf}{}xms;
        system "/usr/bin/pdftoppm $get_dir/$cf $new -jpeg -f 1 -singlefile";
            # the above added .jpg to $new
        $new .= ".jpg";
        # forget resizing and compressing
        # it proved unreliable.  big is okay
        #my $tmp = "/tmp/card$$";
        #system "/usr/bin/convert -resize 1000x $new $tmp";
        #system "/usr/bin/convert -strip -interlace Plane -quality 65%"
        #     . " $tmp $new";
        #unlink $tmp;
        $cf =~ s{pdf}{jpg}xms;
    }
    my $person_name;
    my ($person_id) = $f =~ m{\A (\d+)[.]}xms;
    if ($person_id) {
        my $person = model($c, 'Person')->find($person_id);
        $cf = 'covid_vax_'
            . $person->first() . '_' . $person->last()
            . ".$suffix"
            ;
        $cf =~ s{[ ]}{ }xmsg;   # for first (or last) names like Mary Beth
        rename "$get_dir/$f", "$get_dir/$cf";
        if ($person) {
            $person->update({
                covid_vax => $cf,
            });
            $person_name = $person->name;
        }
        else {
            # a stray file from somewhere?
            unlink "$get_dir/$cf";
            return;
        }
    }
    else {
        #
        # the file is named "FIRST_LAST_TIME.suffix"
        # because it was uploaded during an online registration.
        # the filename is stored in the x_covid_vax field.
        # just get the file (in $get_dir) for later use
        # when the registration is "brought in".
        # extract the person name from the filename
        #
        # we can't update the person yet because the
        # Person record may not have been created yet.
        #
        ($person_name) = $f =~ m{\A (.*)_\d+[.]}xms;
        $person_name =~ s{_}{ }xmsg;
    }
    $person_name = "<a target=_blank href='https://akash.mountmadonna.org"
                 . "/person/view_covid/$person_name/$cf'>"
                 . "$person_name</a>"
                 ;
    email_letter($c,
        to      => $string{covid_notify},
        from    => 'Mount Madonna Center <reservations@mountmadonna.org>',
        subject => 'COVID-19 Vaccination Card',
        html    => "Got COVID-19 vaccination card for $person_name",
        activity_msg => "Received COVID-19 Vaccination card for $person_name.",
    );
}

#
# obsolete - stopped doing this at some point...
#
# a temple user - either to create or update
# does Shantam send it for update only when something has changed???
# in add_or_update_deduping we return 'no change' if nothing has changed.
# the filename is the temple_id
# opt_in - means what?   which to set?  all???
#
sub get_temple {
    my ($get_dir, $f) = @_;

    open my $in, '<', "$get_dir/$f"
        or quit("cannot open $get_dir/$f");
    my $line = <$in>;
    chomp $line;
    close $in;
    my %hash;
    @hash{qw/ first last email tel_cell addr1 addr2
              city st_prov zip_post opt_in /}
        = split m{\|}, $line;
    $hash{temple_id} = $f;  # the filename is the temple_id
    $hash{temple_id} =~ s{-\d+\z}{}xms;     # this is for testing only
    $hash{tel_home} = '';
    $hash{tel_work} = '';
    $hash{sex} = '';
    @hash{qw/
        e_mailings
        snail_mailings
        share_mailings
    /} = (0) x 5;
    if ($hash{opt_in}) {
        @hash{qw/
            e_mailings
            share_mailings
        /} = (1) x 3;
    }
    my ($person_id, $person, $status) = add_or_update_deduping(
        $c, \%hash,
        affil_ids => $system_affil_id_for{'Temple Guest'},
    );
    msg sprintf "temple %s %s - %s",
                $person->first, $person->last, $status;
}

sub kayakalpa {
    return unless @kayakalpa;
    my $fmt = "%A, %B %e, %Y";
    KK:
    for my $href (@kayakalpa) {
        my ($program, $p_sdate, $p_edate, $extradays,
            $arrive, $leave, $dates);
        if ($href->{pid} != 0) {
            my $prog = model($c, 'Program')->find($href->{pid});
            if (! $prog) {
                quit("unknown program id: $href->{pid}");
            }
            $program = $prog->title;
            $p_sdate = date($prog->sdate);
            $p_edate = date($prog->edate);
            if ($href->{progchoice} eq 'full') {
                $p_edate += $extradays;
            }
            $dates = fmt_dates($p_sdate, $p_edate);
        }
        else {
            $program = "Personal Retreat";
            $dates = fmt_dates(date($href->{sdate}), date($href->{edate}));
        }
        my $html;
        my $dir = 'root/static/templates/letter';
        my $tt = Template->new(
            INCLUDE_PATH => $dir,
            INTERPOLATE => 1,
        ) or quit("template new error: " . Template->error());
        $tt->process(
            'kayakalpa.tt2',
            {
                first   => $href->{first},
                program => $program,
                dates   => $dates,
            },
            \$html,
        ) or quit("template error: " . $tt->error());
        email_letter($c,
            to       => $href->{email},
            cc       => "Kaya Kalpa <$string{kayakalpa_email}>",
            from     => "Kaya Kalpa <$string{kayakalpa_email}>",
            subject  => "Massage/Bodywork Request during '$program' from $dates",
            html     => $html,
            activity_msg => "Email kayakalpa to $href->{first} $href->{last}",
        );
    }
}

sub fmt_dates {
    my ($start, $end) = @_;
    return fmt_date($start) . " to " . fmt_date($end);
}
sub fmt_date {
    my ($dt) = @_;
    return $dt->format("%a %b ") . $dt->day;
}

sub main {
    initialize();
    $ftp = ftp_connect(              # mountmadonna.org
        site     => $string{ftp_site},
        login    => $string{ftp_login},
        password => $string{ftp_password},
    );
    # MMC Transactions
    get_files($ftp, $string{ftp_transactions},
              $online, \&check_transaction, 'MMC');

    # Rental Grids
    get_files($ftp, $string{ftp_rental_dir},
              $grid, \&check_grid);

    # MList Requests
    get_files($ftp, $string{ftp_mlist_requests},
              $mlist_done, \&process_mlist);

    # Membership Payments
    get_files($ftp, $string{ftp_omp_dir},
              $omp_dir, \&get_omp);

    # Rental Deposit Payments
    get_files($ftp, $string{ftp_rental_deposit_dir_paid},
              $rental_deposit_dir, \&get_rental_deposit);

    # MMC Payment Requests
    get_files($ftp, $string{req_mmc_dir_paid},
              $req_mmc_dir, \&process_req_payments);

    # MMC Meal Requests
    get_files($ftp, $string{ftp_meal_requests_dir},
              $meal_requests_done, \&process_meal_requests);

    # New HFS Memberships
    get_files($ftp, $string{ftp_new_hfs_dir},
              $new_hfs_dir, \&process_new_hfs);

    # Gift Cards
    get_files($ftp, $string{ftp_gift_cards_dir},
              $gift_cards_done, \&process_gift_cards);

    # COVID-19 Vaccinations
    get_files($ftp, $string{ftp_covid_vax_dir},
              $covid_vax_dir, \&process_covid_vax);

    $ftp->quit();   # all done with MMC

    $ftp = ftp_connect(           #  mountmadonnainstitute.org
        site     => $string{ftp_mmi_site},
        login    => $string{ftp_mmi_login},
        password => $string{ftp_mmi_password},
    );

    # MMI Payment Requests
    get_files($ftp, $string{req_mmi_dir_paid},
              $req_mmi_dir, \&process_req_payments);

    # MMI Transactions - obsolete, actually
    get_files($ftp, $string{ftp_mmi_transactions},
              $online, \&check_transaction, 'MMI');

    $ftp->quit();   # all done with MMI

    mlist_alerts();
    omp_alert();
    kayakalpa();
    finalities();
}

main();

#!/usr/bin/perl
use strict;
use warnings;
=comment

1) Ftp-get all transaction files from www.mountmadonna.org
created by the 'relay' program.  The names of these files
are the ids of the most recent authorize.net transactions.
Put the files in root/static/online

2) Get all email from authorize@hanumanfellowship.org.
This address is one of the recipients of the "Merchant Email Receipts"
sent by authorize.net after every transaction.

A. If a transaction id found within the email is NOT
among the transaction ids we got in 1) AND it is not in 
root/static/online/<trans_id> (or the online_done/ dirs)
THEN synthesize a transaction file from the info in the email
and mark it as such.

B. report the following untoward things via an email
to jon@logicalpoetry.com:  

    - unable to make a connection via ftp or pop3
    - misformatted emails

=cut
use DBI;
use Net::FTP;
use FindBin;
chdir "$FindBin::Bin/..";

my $Msg = "";       # globals (capitalized to emphasize this)
my $Error = 0;
my $Run_File = "grab_running";

if (-f $Run_File) {
    my $t = (stat($Run_File))[9];
    if (time() - $t > 5*60) {
        #
        # a stale run file (older than 5 minutes).
        # it somehow got left behind from a previous run.
        # remove it and continue.
        #
        unlink $Run_File;
    }
    else {
        #
        # we have been invoked via "Grab New" in Reg.
        # but we are still validly running via cron!
        #
        exit;
    }
}
open my $run, ">", $Run_File;
close $run;

# we need some values from the database
# to know where to connect to mysql.
#
my $dbh = DBI->connect(undef, "sahadev", "JonB")
    or my_die("oh no DBI");
my $sth = $dbh->prepare("
    select the_key, value
    from string
    where the_key like 'ftp_%'
       or the_key like 'smtp_%'
");
$sth->execute();
my %string;
while (my ($the_key, $value) = $sth->fetchrow_array()) {
    $string{$the_key} = $value;
}

my $ftp = Net::FTP->new($string{ftp_site}, Passive => $string{ftp_passive})
    or my_die("cannot connect to $string{ftp_site}");    # not die???
$ftp->login($string{ftp_login}, $string{ftp_password})
    or my_die("cannot login " . $ftp->message);
$ftp->cwd($string{ftp_transactions})
    or my_die("cannot cwd to $string{ftp_transactions} " . $ftp->message);
$ftp->ascii();

my %ids = ();

#
# get transaction files from www.mountmadonna.org/cgi-bin/transactions
#
TRANSACTION:
for my $f ($ftp->ls()) {
    if ($f eq '.' || $f eq '..') {
        next TRANSACTION;
    }
    $ids{$f} = 1;
    if (! $ftp->get($f, "root/static/online/$f")) {
        my_warn("no get of $f");
        next TRANSACTION;
    }
    my ($last, $first) = ("", "");
    if (open my $in, "<", "root/static/online/$f") {
        LINE:
        while (my $line = <$in>) {
            if ($line =~ m{x_fname => (.*)}) {
                $first = $1;
                last LINE if $last;
            }
            elsif ($line =~ m{x_lname => (.*)}) {
                $last = $1;
                last LINE if $first;
            }
        }
        close $in;
    }
    $Msg = "  ftp: $f - $last, $first\n";
    $ftp->delete($f);
}
$ftp->quit();

my %mnum = qw/
    Jan 1
    Feb 2
    Mar 3
    Apr 4
    May 5
    Jun 6
    Jul 7
    Aug 8
    Sep 9
    Oct 10
    Nov 11
    Dec 12
/;

#
# get all email sent to authorize@hanumanfellowship.org.
#
use Mail::POP3Client;
my $pop = new Mail::POP3Client(
    USER     => "authorize+hanumanfellowship.org",
    PASSWORD => "Ashtanga!",
    HOST     => "mail.hanumanfellowship.org"
);
if (! $pop) {
    my_die("no pop")
}
LETTER:
for (my $i = 1; $i <= $pop->Count(); ++$i) {
    my ($from, $subj) = ("", "");
    for my $h ($pop->Head($i)) {
        if ($h =~ m{^From:\s+(.*)}i) {
            $from = $1;
        }
        elsif ($h =~ m{^Subject:\s+(.*)}i) {
            $subj = $1;
        }
    }
    if (! (
        $from && $from =~ m{emailreceipts\@authorize.net}
        &&
        $subj && $subj =~ m{Merchant Email Receipt}
        )
    ) {
        dump_it($i, "from/subj error");
        next LETTER;
    }
    my @lines = $pop->Body($i);
    #
    # First get the transaction id, email,
    # city, state, zip, country and the amount.
    # also get the last and first names for the status message.
    # They're in a different section from the x_ vars.
    # We DO unnecessarily go through the @lines twice.  It could
    # be optimized a little - but speed is not the issue here.
    #
    my ($trans_id, $email, $city, $state, $zip, $country, $amount);
    my ($last, $first) = ("", "");
    my ($day, $mon, $year, $hour, $min, $sec, $ampm);

    for my $l (@lines) {
        if ($l =~ m{Transaction ID : (.*)}) {
            $trans_id = $1;
        }
        elsif ($l =~ m{E-Mail : (.*)}) {
            $email = $1;
        }
        elsif ($l =~ m{City : (.*)}) {
            $city = $1;
        }
        elsif ($l =~ m{State/Province : (.*)}) {
            $state = $1;
        }
        elsif ($l =~ m{Zip/Postal Code : (.*)}) {
            $zip = $1;
        }
        elsif ($l =~ m{Country : (.*)}) {
            $country = $1;
            if ($country eq "USA") {
                $country = "";
            }
        }
        elsif ($l =~ m{Amount : (\d+)}) {
            $amount = $1;
        }
        elsif ($l =~ m{Date/Time : (.*)}) {
            my $date_time = $1;
            ($day, $mon, $year) = $date_time =~ m{(\d+)-(...)-(\d+)};
            $mon = $mnum{$mon};
            ($hour, $min, $sec, $ampm)
                = $date_time =~ m{(\d\d):(\d\d):(\d\d) (..)$};
            $hour = 0   if $hour == 12 && $ampm eq 'AM';
            $hour += 12 if $hour  < 12 && $ampm eq 'PM';
            --$hour if $hour > 0;       # not quite right but
                                    # I don't want to mess with a new day
                                    # in case we cross a day boundary.
                                    # shouldn't matter, right?

        }
        elsif ($l =~ m{x_lname : (.*)}) {
            $last = $1;
        }
        elsif ($l =~ m{x_fname : (.*)}) {
            $first = $1;
        }
    }
    for my $x (
        $trans_id, $email, $city, $state, $zip,
        $country, $amount, $first, $last,
        $day, $mon, $year, $hour, $min, $sec, $ampm
    ) {
        if (! defined $x) {
            dump_it($i, "flaw in format: $x");
            next LETTER;
        }
    }

    if (exists $ids{$trans_id}) {
        #
        # already gotten above.
        # no problem - normal behavior.
        # this is what we hope.
        #
        $Msg .= "email: $trans_id - $last, $first"
             .  " - just got above\n";
        $pop->Delete($i);
        next LETTER;
    }
    if (-f "root/static/online/$trans_id") {
        #
        # already gotten on a previous call to grab_new
        #
        $Msg .= "email: $trans_id - $last, $first"
             .  " - gotten previously\n";
        $pop->Delete($i);
        next LETTER;
    }
    my ($now_mon, $now_year) = (localtime())[4, 5];
    ++$now_mon;
    $now_year += 1900;
    my $now = sprintf("%d-%02d", $now_year, $now_mon);
    if (-f "root/static/online_done/$now/$trans_id") {
        #
        # already gotten on a previous call to grab_new
        # AND already processed and moved aside.
        #
        $Msg .= "email: $trans_id - $last, $first"
             .  " - gotten previously and processed\n";
        $pop->Delete($i);
        next LETTER;
    }
    #
    # we have found a 'missing' online registration.
    # without this email it would not have been seen at all.
    # synthesize a transaction file.
    #
    my $fname = "root/static/online/$trans_id";
    my $out;
    if (! open $out, ">", $fname) {
        dump_it($i, "could not open $fname");
        next LETTER;
    }
    printf {$out} "x_date => %d/%d/%d\n", $mon, $day, $year;
    printf {$out} "x_time => %02d:%02d\n", $hour, $min;
    print  {$out} "x_trans_id => $trans_id\n";
    print  {$out} "x_amount => $amount\n";
    print  {$out} "x_state => $state\n";
    print  {$out} "x_city => $city\n";
    print  {$out} "x_country => $country\n";
    print  {$out} "x_zip => $zip\n";
    print  {$out} "x_email => $email\n";
    print  {$out} "x_synthesized => 1\n";        # to mark it for Reg
    for my $l (@lines) {
        if ($l =~ m{^x_(\w+)}) {
            my $type = $1;
            $l =~ s{:}{=>};
            if ($type =~ m{home|work|cell}) {
                my ($phone) = $l =~ m{=> (.*)};
                my $n = $phone =~ tr/0-9/0-9/;      # count digits
                if ($n == 10 && $phone =~ m{^[0-9\(\)-. /]+$}) {
                    #
                    # an American phone number
                    # reformat it in a standard way
                    #
                    $phone =~ s{[^0-9]}{}g;
                    $phone = substr($phone, 0, 3) . "-"
                           . substr($phone, 3, 3) . "-"
                           . substr($phone, 6, 4);
                    $l =~ s{=>.*}{=> $phone};
                }
            }
            print {$out} "$l\n";
        }
    }
    close $out;
    $Msg .= "email: $trans_id - $last, $first\n";
    $pop->Delete($i);
}
$pop->Close();
finalities();
exit;


#
# four utility functions
#

sub my_die {
    $Error = 1;
    $Msg .= "@_\n";
    finalities();
    exit;
}

sub my_warn {
    $Error = 1;
    $Msg .= "@_\n";
}

sub dump_it {
    my ($i, $err) = @_;

    $Error = 1;
    $Msg .= "$err\n\n" . scalar($pop->HeadAndBody($i));
    $pop->Delete($i);
}

use Mail::Sender;
sub finalities {
    if ($Msg) {
        # write to a file (uniquely named) and send a letter to Jon.
        if (open my $out, ">", "error-" . time()) {
            print {$out} $Msg;
            close $out;
        }
        my $mail_sender = Mail::Sender->new({
            smtp => $string{smtp_server},
            port => $string{smtp_port},
        });
        if ($mail_sender && $mail_sender->Open({
            to       => 'jon@logicalpoetry.com',
            from     => 'Grab New <reservations@mountmadonna.org>',
            subject  => "Grab New "
                        . ($Error? "Failure"
                           :       "Status"),
            ctype    => "text/plain",
            encoding => "7bit",
        })) {
            $mail_sender->SendLineEnc($Msg);
            $mail_sender->Close();
        }
    }
    unlink $Run_File;
}

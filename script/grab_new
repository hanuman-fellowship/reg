#!/usr/bin/perl
use strict;
use warnings;

=begin comment

-1) Log everything that happens in the running of this script.
It is is run from cron in the background.
Append the log messages for this one run to a file named after
the current day.  If this is the first run for the day start
the file anew.

0) Make sure that the net is available by trying to ping mountmadonna.org.
Otherwise simply exit.

1) Ftp-get all transaction files from www.mountmadonna.org
created by the 'relay' program.  The names of these files
are the ids of the most recent authorize.net transactions.
Put the files in root/static/online.

1a) If one of the above transaction files has a line like
'x_description => Temple Donation ...'
it is a temple donation and requires special handling.   
Create a Payment record for the person to the 'Temple' Extra Account.
Send a proper thank you letter???

2) Get recently modified rental grid files into root/static/grid.

3) Get mailing list requests (from MMC and MMI) into 
root/static/mlist_done/$yyyy_mm and insert them into the people table.
Notify the reception office who and which so they can
send them a brochure.

4) Get ride requests into root/static/rides.

5) For registrations that indicated they would like
to be contacted about massage send Kaya Kalpa a letter
with their contact information and which program and when
they'll be here.

Also send the registrant a letter (actually it's the same letter
that they are Cc'ed on) saying that they will
be contacted by someone at Kaya Kalpa two to three weeks
before the program to arrange for the bodywork.

6) Get people that recently registered on the temple
reservation site and import them directly into the People table.

7) Get MMI payment requests that have been paid and morph
them into actual payments.

8) Get MMI standalone course registations

9) Get online membership payments

10) Get new and updated temple users.

11) Maybe ... Get all email from authorize@hanumanfellowship.org.
This address is one of the recipients of the "Merchant Email Receipts"
sent by authorize.net after every transaction.

A. If a transaction id found within the email is NOT
among the transaction ids we got in 1) AND it is not in 
root/static/online/<trans_id> (or the online_done/ dirs)
THEN synthesize a transaction file from the info in the email
and mark it as such.

B. report the following untoward things via an email
to jonb@logicalpoetry.com:  

    - unable to make a connection via ftp or pop3
    - misformatted emails

=end

=cut

use lib 'lib';
use Util qw/
    model
    db_init
    normalize
    add_or_update_deduping
    digits_only
    commify
    x_file_to_href
    email_letter
    slurp
/;

use RetreatCenterDB;    # ??? why can't we move this to Util?
use Global qw/
    %string
    %system_affil_id_for
/;

use Template;
use Date::Simple qw/
    date
    today
/;
use Time::Simple qw/
    get_time
/;
use Net::Ping;
use Net::FTP;
use File::FTP;      # this is mine
use File::Basename 'basename';

use FindBin;
chdir "$FindBin::Bin/..";

# globals
my $today = today();
my $c;
my $ftp;
my $run_file = "grab_running";
my ($log, $log_name);
my $nomp = 0;
my $nrides = 0;
my ($now_t24, $today_d8, $year_mon_dir);
my ($temple_xaccount_id);
my %ids = ();   # needed any more??
my @kayakalpa;  # an array of hashrefs - these people requested
                # information about bodywork.
my @mlist_alerts;   # an array of hashrefs - who to send
                    # brochures for MMI/MMC.

# directories
my ($online, $grid, $temple, $mlist_done, $rides,
    $req_mmi_dir, $omp_dir, $temple_donation);
my $something_happened = 0;

sub msg {
    if ($_[0] !~ m{\A (.)\1}xms) {
        print {$log} '   ';
    }
    print {$log} @_;
    if (pop !~ m{\n$}xms) {
        print {$log} "\n";
    }
}

sub quit {
    msg @_, "\n";
    close $log;
    # try to email $log_name to Jon ???
    exit;
}

sub failed {
    my ($rc) = @_;
    return $rc? '': ' - failed';
}

sub initialize {
    my $now = get_time();
    $now_t24 = $now->t24;
    $today_d8 = $today->as_d8();
    $year_mon_dir = $today->format("%Y-%m");
    $log_name = 'grab_new_log';
    open $log, '>', $log_name
        or die "no $log_name! :(\n";
    msg "%% " . $now->t12;

    if (-f $run_file) {
        my $t = (stat($run_file))[9];
        if (time() - $t > 5*60) {
            #
            # a stale run file (older than 5 minutes).
            # it somehow got left behind from a previous run.
            # remove it and continue.
            # use the pid instead with kill?
            #
            unlink $run_file;
        }
        else {
            #
            # we have been invoked via "Grab New" in Reg.
            # but we are still validly running via cron!
            #
            quit("still running via cron");
        }
    }

    # touch the run file
    open my $run, ">", $run_file;
    close $run;

    if (! $ENV{FILE_FTP_DIR}) {     # are we testing or not?
        my $p = Net::Ping->new();
        if (!$p->ping("mountmadonna.org")) {
            quit("no ping of mountmadonna.org");
        }
    }

    $c = db_init();
    Global->init($c, 1, 1);
    $string{mmc_email} = $string{reception_email};  # see *1 below

    # for temple donations
    my @xaccounts = model($c, 'XAccount')->search({
                        descr => 'Temple',
                    });
    if (@xaccounts == 1) {
        $temple_xaccount_id = $xaccounts[0]->id;
    }
    else {
        quit("could not find Temple Extra Account");
    }

    my $rst = "root/static";
    $online          = make_dir("$rst/online");
    $grid            = make_dir("$rst/grid");
    $temple          = make_dir("$rst/temple_done/$year_mon_dir");
    $mlist_done      = make_dir("$rst/mlist_done/$year_mon_dir");
    $rides           = make_dir("$rst/rides");
    $req_mmi_dir     = make_dir("$rst/req_mmi/$year_mon_dir");
    $omp_dir         = make_dir("$rst/omp");
    $temple_donation = make_dir("$rst/temple_donation");
}

sub finalities {
    unlink $run_file;
    close $log;
    my $log_str = slurp $log_name;
    if ($something_happened) {
        # not forever ... just until you trust it
        # then comment this out
        email_letter($c,
            to      => 'jon@suecenter.org',
            from    => 'jon@suecenter.org',
            subject => 'grab_new',
            html    => $log_str,
        );
    }
    my $dow_name = "output/grab_new_" . $today->format("%a");
    my $mode = (! -f $dow_name || -M $dow_name > 1)? '>': '>>';
    if (open my $out, $mode, $dow_name) {
        print {$out} $log_str;
        close $out;
    }

    # at what point do the req_mmi_payments expire???
    # a cron job on the remote site to clear them after n days?
    # also a cron job to clear the grid files after
    # the rental is over - two week delays?
    # ask/confirm with Rachel and Barnaby
}

sub ftp_connect {
    my (%arg) = @_;

    my $ftp_class = $ENV{FILE_FTP_DIR}? 'File::FTP': 'Net::FTP';
    my $ftp = $ftp_class->new($arg{site}, Passive => $arg{passive})
                  or quit("cannot connect to $arg{site}");
    $ftp->login($arg{login}, $arg{password})
        or quit("cannot login to $arg{site}: " . $ftp->message);
    $ftp->ascii();
    return $ftp;
}

sub make_dir {
    my ($d) = @_;
    mkdir $d if ! -d $d;
    return $d;
}

#
# using $ftp cd to the remote dir
# get all files there into $get_dir
# if $code_ref is supplied call it on each file.
#
sub get_files {
    my ($title, $ftp, $remote_dir, $get_dir, $code_ref) = @_;

    msg "** $title";
    $ftp->cwd($remote_dir)
        or quit("cannot cwd to $remote_dir " . $ftp->message);
    mkdir $get_dir if ! -d $get_dir;
    my $nfiles = 0;
    FILE:
    for my $f ($ftp->ls()) {
        if ($f eq '.' || $f eq '..') {
            next FILE;
        }
        $ftp->get($f, "$get_dir/$f");
        ++$nfiles;
        if ($code_ref) {
            $code_ref->($get_dir, $f);
        }
        $ftp->delete($f);
    }
    if ($nfiles) {
        my $pl = $nfiles == 1? '': 's';
        msg "$nfiles file$pl";
        $something_happened = 1;
    }
}

sub check_transaction {
    my ($get_dir, $f) = @_;

    $ids{$f} = 1;       #  needed any more???
    my $href = x_file_to_href("$get_dir/$f");
    my $kk   = $href->{kayakalpa};
    my $desc = $href->{description};
    if ($kk && $kk eq 'yes') {
        push @kayakalpa, $href;
    }
    elsif ($desc && $desc =~ m{\A Temple \s+ Donation}xms) {
        temple_donation($href, $f);
        return;
    }
    msg "transaction $f, $href->{first} $href->{last}, $href->{title}";
}

sub temple_donation {
    my ($href, $f) = @_;

    msg "temple donation $href->{amount}";

    # add the person if needed
    # ensure an affiliation is there.
    # add the payment to the Temple xaccount
    # move the file into the archive by month

    $href->{e_mailings} =
    $href->{snail_mailings} = 
    $href->{mmi_e_mailings} = 
    $href->{mmi_snail_mailings} = 
    $href->{share_mailings} = -1;   # don't change these
                                    # it's just a donation

    my ($person_id, $person, $status) = add_or_update_deduping(
        $c, $href,
        affil_ids => $system_affil_id_for{'Temple Guest'},
    );
    msg sprintf "%s %s - %s", $person->first, $person->last, $status;
    # now we can add the payment record
    model($c, 'XAccountPayment')->create({
        xaccount_id => $temple_xaccount_id,
        person_id   => $person_id,
        amount      => $href->{amount},
        type        => 'D',               # credit
        what        => 'Online temple donation',
        user_id     => 0,                 # what other user id?
        the_date    => $today_d8,
        time        => $now_t24,
    });
    # move the file into the archive - we have finished with it
    rename "$online/$f", "$temple_donation/$f";
    # email thank you again???
    # email temple people interested in donations???
}


#
#
# send the admins (mmc and mmi) a letter telling them
# who/where to send the brochure(s) - include the special requests.
#
sub mlist_alerts {
    msg "-- mlist alerts";
    return unless @mlist_alerts;
    TYPE:
    for my $type (qw/ mmc mmi /) {
        my $TYPE = uc $type;
        my $html = "";
        ALERT:
        for my $href (@mlist_alerts) {
            next ALERT if $href->{type} ne $type;
            $html .= <<"EOH";
<p>
$href->{first} $href->{last}<br>
$href->{addr1}<br>
$href->{city}, $href->{st_prov}<br>
$href->{zip_post}<br>
EOH
            if ($href->{country}) {
                $html .= "$href->{country}<br>\n";
            }
            if ($href->{interest}) {
                $html .= "Interest: $href->{interest}<br>\n";
            }
            if ($href->{request}) {
                $html .= "Special Request: $href->{request}<br>\n"
            }
        }
        next TYPE if ! $html;
        my $email = $string{"$type\_email"};   # *1 mmc_email == reception_email
        my $rc = email_letter($c,
            to      => "$TYPE Mail Admin <$email>",
            from    => 'Mount Madonna Center <reservations@mountmadonna.org>',
            subject => "Online Mailing List Requests",
            html    => $html,
        );
        msg "email to $type $email" . failed($rc);
    }
}

sub process_mlist {
    my ($get_dir, $f) = @_;

    # was it for mmi or mmc?
    open my $in, "<", "$get_dir/$f"
        or quit("cannot open $get_dir/$f: $!\n");
    my %hash;
    while (my $line = <$in>) {
        chomp $line;
        if (my ($key, $val) = $line =~ m{^(\w+)\s+(.*)}) {
            $hash{$key} = $val;
        }
        else {
            $hash{$line} = '';
        }
    }
    close $in;
    $hash{addr1} = $hash{street};
    $hash{addr2} = '';
    my $type = $hash{type};
    my $interest = $hash{interest};
    for my $k (qw/ cell home work /) {
        $hash{"tel_$k"} = $hash{$k};
    }
    $hash{sex} = $hash{gender} eq 'female'? 'F': 'M';
    $hash{request} =~ s{NEWLINE}{\n}g;      # how did the NEWLINE get there???

    # remove unneeded ones
    for my $k (qw/
        street type interest
        cell home work gender
        email2
    /) {
        delete $hash{$k};
    }
    my @affil_ids;
    if ($type eq 'mmi') {
        if ($interest eq 'All Schools') {
            for my $k (grep { /MMI/ } keys %system_affil_id_for) {
                push @affil_ids, $system_affil_id_for{$k};
            }
        }
        else {
            push @affil_ids, $system_affil_id_for{"MMI - $interest"};
        }
    }
    my ($person_id, $person, $status) = add_or_update_deduping(
        $c, \%hash,
        affil_ids => \@affil_ids,
        request_to_comment => 1,
    );
    msg sprintf "%s %s - %s", $person->first, $person->last, $status;
    # record name, address for emailing all later to the reception office.
    # see sub mlist_alerts()
    # include type and comment
    #
    push @mlist_alerts, {
        type => $type,
        interest => $interest,
        map { $_ => $hash{$_} } qw/
            first last
            addr1 city st_prov zip_post country
            request
        /,
    };
}

sub ride_alert {
    msg "-- ride_alert";
    if ($nrides) {
        my $rc = email_letter($c,
            to      => "MMC Transportation <$string{ride_email}>",
            from    => 'Mount Madonna Center <reservations@mountmadonna.org>',
            subject => "Online Ride Request",
            html    => "There is an online ride request waiting"
                     . " for you in Reg."
        );
        msg "email ride request waiting to $string{ride_email}"
            . failed($rc);
    }
}

sub omp_alert {
    msg "-- omp_alert";
    if ($nomp) {
        my $rc = email_letter($c,
            to      => "HFS Membership <$string{mem_email}>",
            from    => 'Mount Madonna Center <reservations@mountmadonna.org>',
                                # what else???
            subject => "Membership Payment",
            html    => "There is an online membership payment waiting for you in Reg."
        );
        msg "email about omp waiting" . failed($rc);
    }
}

sub process_mmi_payments {
    my ($get_dir, $f) = @_;
    my %hash = %{ do "$get_dir/$f" };
    #
    # this hash contains keys:
    #    py_desc
    #       which has multiple ~ separated fields
    #       which are | separated fields of
    #           amount, note, glnum
    #    code
    #    reg_id
    #    person_id
    #    total
    #    first
    #    last
    #
    # - create RegPayment records with the above
    # - clear requested payments with the code
    # - adjust the balance in the registration
    # - log it
    #
    for my $py (split m{~}, $hash{py_desc}) {
        my ($amount, $note, $glnum) = split m{\|}, $py;
        $amount =~ s{,}{}xmsg;
        model($c, 'MMIPayment')->create({
            reg_id    => $hash{reg_id},
            deleted   => '',
            the_date  => $today_d8,
            person_id => $hash{person_id},
            type      => 'O',       # online
            amount    => $amount,
            glnum     => $glnum,
            note      => $note,
        });
    }
    # remove all requests with the code
    model($c, 'RequestedMMIPayment')->search({
        code => $hash{code},
    })->delete();

    # History record
    model($c, 'RegHistory')->create({
        reg_id   => $hash{reg_id},
        the_date => $today_d8,
        time     => $now_t24,
        user_id  => 0,
        what     => "Got total payment of \$" . commify($hash{total}) . '.',
    });

    # adjust the balance
    model($c, 'Registration')->find($hash{reg_id})->update({
        balance => \"balance - $hash{total}",
    });
# let's notify someone that the payment was made!???
    msg "got req mmi payment totaling $hash{total} for $hash{first} $hash{last}";
}

#
# a temple user - either to create or update
# does Shantam send it for update only when something has changed???
# the filename is the temple_id
# opt_in - means what?   which to set?  all???
#
sub get_temple {
    my ($get_dir, $f) = @_;

    open my $in, '<', "$get_dir/$f"
        or quit("cannot open $get_dir/$f");
    my $line = <$in>;
    chomp $line;
    close $in;
    my %hash;
    @hash{qw/ first last email tel_cell addr1 addr2
              city st_prov zip_post opt_in /}
        = split m{\|}, $line;
    $hash{temple_id} = $f;  # the filename is the temple_id
    $hash{temple_id} =~ s{-\d+\z}{}xms;     # this is for testing only
    $hash{tel_home} = '';
    $hash{tel_work} = '';
    $hash{sex} = '';
    @hash{qw/
        e_mailings
        snail_mailings
        mmi_e_mailings
        mmi_snail_mailings
        share_mailings
    /} = (0) x 5;
    if ($hash{opt_in}) {
        @hash{qw/
            e_mailings
            mmi_emailings
            share_mailings
        /} = (1) x 3;
    }
    my ($person_id, $person, $status) = add_or_update_deduping(
        $c, \%hash,
        affil_ids => $system_affil_id_for{'Temple Guest'},
    );
    msg sprintf "%s %s - %s", $person->first, $person->last, $status;
}

sub kayakalpa {
    msg "-- kayakalpa";
    return unless @kayakalpa;
    my $fmt = "%A, %B %e, %Y";
    KK:
    for my $href (@kayakalpa) {
        my ($program, $p_sdate, $p_edate, $extradays,
            $arrive, $leave, $dates);
        if ($href->{pid} != 0) {
            my $prog = model($c, 'Program')->find($href->{pid});
            if (! $prog) {
                quit("unknown program id: $href->{pid}");
            }
            $program = $prog->title;
            $p_sdate = date($prog->sdate);
            $p_edate = date($prog->edate);
            if ($href->{progchoice} eq 'full') {
                $p_edate += $extradays;
            }
            $dates = fmt_dates($p_sdate, $p_edate);
        }
        else {
            $program = "Personal Retreat";
            $dates = fmt_dates(date($href->{sdate}), date($href->{edate}));
        }
        my $html;
        my $tt = Template->new(
            INTERPOLATE => 1,
        ) or quit("template new error: " . Template->error());
        $tt->process(
            'kayakalpa.tt2',
            {
                first   => $href->{first},
                program => $program,
                dates   => $dates,
            },
            \$html,
        ) or quit("template error: " . $tt->error());
        my $rc = email_letter($c,
            to       => $href->{email},
            cc       => "Kaya Kalpa <$string{kayakalpa_email}>",
            from     => "Kaya Kalpa <$string{kayakalpa_email}>",
            subject  => "Massage/Bodywork Request during '$program' from $dates",
            html     => $html,
        );
        msg "email to $href->{first} $href->{last}" . failed($rc);
    }
}

sub fmt_dates {
    my ($start, $end) = @_;
    return fmt_date($start) . " to " . fmt_date($end);
}
sub fmt_date {
    my ($dt) = @_;
    return $dt->format("%a %b ") . $dt->day;
}

sub main {
    initialize();
    $ftp = ftp_connect(              # mountmadonna.org
        site     => $string{ftp_site},
        passive  => $string{ftp_passive},
        login    => $string{ftp_login},
        password => $string{ftp_password},
    );
    get_files("MMC Transactions", $ftp, $string{ftp_transactions},
                                  $online, \&check_transaction);

    get_files("Rental Grids",     $ftp, $string{ftp_rental_dir},
                                  $grid);

    get_files("MList Requests",   $ftp, $string{ftp_mlist_requests},
                                  $mlist_done,  \&process_mlist);

    get_files("Rides",            $ftp, $string{ftp_ride_dir},
                                  $rides, sub { $nrides = 1; });

    get_files("Membership Payments", $ftp, $string{ftp_omp_dir},
                                  $omp_dir, sub { $nomp = 1 });
    $ftp->quit();   # all done with MMC

    $ftp = ftp_connect(           #  mountmadonnainstitute.org
        site     => $string{ftp_mmi_site},
        passive  => $string{ftp_mmi_passive},
        login    => $string{ftp_mmi_login},
        password => $string{ftp_mmi_password},
    );

    get_files("MMI Payment Requests", $ftp, $string{req_mmi_dir_paid},
                                      $req_mmi_dir,
                                      \&process_mmi_payments);

    get_files("MMI Transactions", $ftp, $string{ftp_mmi_transactions},
                                  $online, \&check_transaction);

    $ftp->quit();   # all done with MMI

    $ftp = ftp_connect(         # hanumanfellowship.org
        site     => $string{ftp_hfs_site},
        passive  => $string{ftp_passive},
        login    => $string{ftp_hfs_user},
        password => $string{ftp_hfs_password},
    );

    get_files("Temple Users", $ftp, $string{ftp_hfs_dir},
                  $temple, \&get_temple);

    $ftp->quit();   # all done with HFS

    mlist_alerts();
    ride_alert();
    omp_alert();
    kayakalpa();

    finalities();
}

main();

__END__

my %mnum = qw/
    Jan 1
    Feb 2
    Mar 3
    Apr 4
    May 5
    Jun 6
    Jul 7
    Aug 8
    Sep 9
    Oct 10
    Nov 11
    Dec 12
/;

#
# get all email sent to authorize@hanumanfellowship.org.
#
use Mail::POP3Client;
my $pop = new Mail::POP3Client(
    USER     => "authorize+hanumanfellowship.org",
    PASSWORD => "Ashtanga!",
    HOST     => "mail.hanumanfellowship.org"
);
if (! $pop) {
    quit("no pop");
}
LETTER:
for (my $i = 1; $i <= $pop->Count(); ++$i) {
    my ($from, $subj) = ("", "");
    for my $h ($pop->Head($i)) {
        if ($h =~ m{^From:\s+(.*)}i) {
            $from = $1;
        }
        elsif ($h =~ m{^Subject:\s+(.*)}i) {
            $subj = $1;
        }
    }
    if (! (
        $from && $from =~ m{emailreceipts\@authorize.net}
        &&
        $subj && $subj =~ m{Merchant Email Receipt}
        )
    ) {
        dump_it($i, "from/subj error");
        next LETTER;
    }
    my @lines = $pop->Body($i);
    #
    # First get the transaction id, email,
    # city, state, zip, country and the amount.
    # also get the last and first names for the status message.
    # They're in a different section from the x_ vars.
    # We DO unnecessarily go through the @lines twice.  It could
    # be optimized a little - but speed is not the issue here.
    #
    my ($trans_id, $email, $city, $state, $zip, $country, $amount);
    my ($last, $first) = ("", "");
    my ($day, $mon, $year, $hour, $min, $sec, $ampm);

    for my $l (@lines) {
        if ($l =~ m{Transaction\s+ID\s*:\s*(.*)}i) {
            $trans_id = $1;
        }
        elsif ($l =~ m{E-Mail\s*:\s*(.*)}i) {
            $email = $1;
        }
        elsif ($l =~ m{City\s*:\s*(.*)}i) {
            $city = $1;
        }
        elsif ($l =~ m{State/Province\s*:\s*(.*)}i) {
            $state = $1;
        }
        elsif ($l =~ m{Zip/Postal\s+Code\s*:\s*(.*)}i) {
            $zip = $1;
        }
        elsif ($l =~ m{Country\s*:\s*(.*)}i) {
            $country = $1;
            if ($country eq "USA") {
                $country = "";
            }
        }
        elsif ($l =~ m{Amount\s*:\s*([\d.]+)}i) {
            $amount = $1;
        }
        elsif ($l =~ m{Date/Time\s*:\s*(.*)}i) {
            my $date_time = $1;
            ($day, $mon, $year) = $date_time =~ m{(\d+)-(...)-(\d+)};
            $mon = $mnum{$mon};
            ($hour, $min, $sec, $ampm)
                = $date_time =~ m{(\d\d):(\d\d):(\d\d) (..)$};
            $hour = 0   if $hour == 12 && $ampm eq 'AM';
            $hour += 12 if $hour  < 12 && $ampm eq 'PM';
            --$hour if $hour > 0;       # not quite right but
                                    # I don't want to mess with a new day
                                    # in case we cross a day boundary.
                                    # shouldn't matter, right?

        }
        elsif ($l =~ m{lname\s*:\s*(.*)}i) {
            $last = $1;
        }
        elsif ($l =~ m{fname\s*:\s*(.*)}i) {
            $first = $1;
        }
    }
    for my $x (
        $trans_id, $email, $city, $state, $zip,
        $country, $amount, $first, $last,
        $day, $mon, $year, $hour, $min, $sec, $ampm
    ) {
        if (! defined $x) {
            dump_it($i, "flaw in format: $x");
            next LETTER;
        }
    }

    if (exists $ids{$trans_id}) {
        #
        # already gotten above.
        # no problem - normal behavior.
        # this is what we hope.
        #
        $Msg .= "email: $trans_id - $last, $first"
             .  " - just got above\n";
        $pop->Delete($i);
        next LETTER;
    }
    if (-f "$online/$trans_id") {
        #
        # already gotten on a previous call to grab_new
        #
        $Msg .= "email: $trans_id - $last, $first"
             .  " - gotten previously\n";
        $pop->Delete($i);
        next LETTER;
    }
    if (-f "root/static/online_done/$/$trans_id") {
        #
        # already gotten on a previous call to grab_new
        # (within the same month)
        # AND already processed and moved aside.
        #
        $Msg .= "email: $trans_id - $last, $first"
             .  " - gotten previously and processed\n";
        $pop->Delete($i);
        next LETTER;
    }
    #
    # we have found a 'missing' online registration.
    # without this email it would not have been seen at all.
    # synthesize a transaction file.
    #
    my $fname = "$online/$trans_id";
    my $out;
    if (! open $out, ">", $fname) {
        dump_it($i, "could not open $fname");
        next LETTER;
    }
    printf {$out} "x_date => %d/%d/%d\n", $mon, $day, $year;
    printf {$out} "x_time => %02d:%02d\n", $hour, $min;
    print  {$out} "x_trans_id => $trans_id\n";
    print  {$out} "x_amount => $amount\n";
    print  {$out} "x_state => $state\n";
    print  {$out} "x_city => $city\n";
    print  {$out} "x_country => $country\n";
    print  {$out} "x_zip => $zip\n";
    print  {$out} "x_email => $email\n";
    print  {$out} "x_synthesized => 1\n";        # to mark it for Reg
    my %P;      # all other x_ named values
    my $got_pid = 0;
    for my $l (@lines) {
        if ($l =~ m{^(x_\w+) : (.*)}) {
            my $type = $1;
            if ($type eq 'x_pid') {
                $got_pid = 1;
            }
            my $val = $2;
            $P{$type} = $val;
            $l =~ s{:}{=>};
            if ($type =~ m{home|work|cell}) {
                my ($phone) = $l =~ m{=> (.*)};
                my $n = $phone =~ tr/0-9/0-9/;      # count digits
                if ($n == 10 && $phone =~ m{^[0-9\(\)-. /]+$}) {
                    #
                    # an American phone number
                    # reformat it in a standard way
                    #
                    $phone =~ s{[^0-9]}{}g;
                    $phone = substr($phone, 0, 3) . "-"
                           . substr($phone, 3, 3) . "-"
                           . substr($phone, 6, 4);
                    $l =~ s{=>.*}{=> $phone};
                }
            }
            print {$out} "$l\n";
            if ($l =~ m{x_kayakalpa => yes}) {
                push @kayakalpa, $trans_id;    
            }
        }
    }
    close $out;
    if (! $got_pid) {
        unlink $fname;
        $Msg .= "refund? transaction_id $trans_id amount $amount\n";
        $pop->Delete($i);
        next LETTER;
    }
    $Msg .= "email: $trans_id - $last, $first\n";
    $pop->Delete($i);
    #
    # send an email with the info to assure the registrant.
    #
    my $html;
    my $tt = Template->new()
        or quit("template new error: " . Template->error());
    $tt->process(
        'email.tt2',
        {
            first    => $first,
            amount   => $amount,
            trans_id => $trans_id,
            %P,
        },
        \$html,
    ) or quit("template error: " . $tt->error());
    my $rc = email_letter($c,
        to       => "$first $last <$email>",
        from     => 'Mount Madonna Center <reservations@mountmadonna.org>',
        subject  => "Online registration for $P{x_title}",
        html     => $html,
    );
    msg "email to $first $last" . failed($rc);
}
$pop->Close();
